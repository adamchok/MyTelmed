/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (function() { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./public/sw-push.js":
/*!***************************!*\
  !*** ./public/sw-push.js ***!
  \***************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("/**\n * MyTelmed Push Notification Service Worker\n * Handles push events, notification clicks, and background sync\n */ // Workbox manifest injection - required for PWA caching\n\nimportScripts(\"https://storage.googleapis.com/workbox-cdn/releases/6.4.1/workbox-sw.js\");\n// Inject the manifest - this will be replaced by Workbox during build\nif (typeof [] !== \"undefined\") {\n    // This ensures the manifest is included in the service worker\n    console.log(\"Workbox manifest loaded\");\n}\n// Constants\nconst NOTIFICATION_TAG_PREFIX = \"mytelmed-\";\nconst CACHE_NAME = \"mytelmed-notifications-v1\";\nconst API_BASE_URL = self.location.origin;\nconst FALLBACK_ICON = \"/assets/logos/mytelmed-logo.png\";\nconst FALLBACK_BADGE = \"/assets/logos/mytelmed-logo.png\";\n// Notification action handlers\nconst NOTIFICATION_ACTIONS = {\n    view: \"View Details\",\n    dismiss: \"Dismiss\",\n    calendar: \"Add to Calendar\",\n    order: \"Order Now\",\n    renew: \"Renew Now\",\n    remind: \"Remind Later\",\n    track: \"Track Delivery\",\n    contact: \"Contact Support\"\n};\n// URL mappings for different notification types\nconst NOTIFICATION_URLS = {\n    APPOINTMENT_REMINDER_PATIENT: \"/appointments\",\n    APPOINTMENT_CONFIRMATION_PATIENT: \"/appointments\",\n    APPOINTMENT_CANCEL_PATIENT: \"/appointments\",\n    APPOINTMENT_BOOKED_PATIENT: \"/appointments\",\n    PRESCRIPTION_CREATED: \"/prescriptions\",\n    PRESCRIPTION_EXPIRING: \"/prescriptions\",\n    PRESCRIPTION_OUT_FOR_DELIVERY: \"/prescriptions/delivery\"\n};\n/**\n * Push event handler - receives notifications from backend\n */ self.addEventListener(\"push\", (event)=>{\n    console.log(\"Push notification received:\", event);\n    if (!event.data) {\n        console.log(\"Push event has no data\");\n        return;\n    }\n    try {\n        // Parse notification payload\n        const payload = event.data.json();\n        console.log(\"Push payload:\", payload);\n        // Validate payload\n        if (!payload.title || !payload.body) {\n            console.error(\"Invalid push payload - missing title or body\");\n            return;\n        }\n        // Show notification\n        event.waitUntil(showNotification(payload));\n    } catch (error) {\n        console.error(\"Error processing push event:\", error);\n        // Show fallback notification\n        event.waitUntil(showFallbackNotification(\"MyTelmed Notification\", \"You have a new notification\"));\n    }\n});\n/**\n * Notification click handler\n */ self.addEventListener(\"notificationclick\", (event)=>{\n    console.log(\"Notification clicked:\", event);\n    const notification = event.notification;\n    const action = event.action;\n    const data = notification.data || {};\n    // Close the notification\n    notification.close();\n    // Handle different actions\n    event.waitUntil(handleNotificationClick(action, data));\n});\n/**\n * Notification close handler\n */ self.addEventListener(\"notificationclose\", (event)=>{\n    console.log(\"Notification closed:\", event);\n    const data = event.notification.data || {};\n    // Track notification dismissal\n    event.waitUntil(trackNotificationEvent(\"dismissed\", data));\n});\n/**\n * Show notification with proper formatting\n */ async function showNotification(payload) {\n    try {\n        const { title, body, icon = FALLBACK_ICON, badge = FALLBACK_BADGE, image, tag, data = {}, actions = [], requireInteraction = false, silent = false, vibrate = [\n            200,\n            100,\n            200\n        ] } = payload;\n        // Create notification options\n        const options = {\n            body,\n            icon,\n            badge,\n            image,\n            tag: tag || \"\".concat(NOTIFICATION_TAG_PREFIX).concat(Date.now()),\n            data: {\n                ...data,\n                timestamp: Date.now(),\n                url: getNotificationUrl(data.notificationType, data)\n            },\n            actions: actions.map((action)=>({\n                    action: action.action,\n                    title: NOTIFICATION_ACTIONS[action.action] || action.title,\n                    icon: action.icon\n                })),\n            requireInteraction,\n            silent,\n            vibrate: silent ? [] : vibrate,\n            renotify: true,\n            persistent: true\n        };\n        console.log(\"Showing notification with options:\", options);\n        // Show the notification\n        await self.registration.showNotification(title, options);\n        // Track notification delivery\n        await trackNotificationEvent(\"delivered\", data);\n        console.log(\"Notification shown successfully\");\n    } catch (error) {\n        console.error(\"Error showing notification:\", error);\n        throw error;\n    }\n}\n/**\n * Show fallback notification when payload is invalid\n */ async function showFallbackNotification(title, body) {\n    try {\n        const options = {\n            body,\n            icon: FALLBACK_ICON,\n            badge: FALLBACK_BADGE,\n            tag: \"\".concat(NOTIFICATION_TAG_PREFIX, \"fallback\"),\n            data: {\n                timestamp: Date.now(),\n                type: \"fallback\"\n            },\n            requireInteraction: false\n        };\n        await self.registration.showNotification(title, options);\n        console.log(\"Fallback notification shown\");\n    } catch (error) {\n        console.error(\"Error showing fallback notification:\", error);\n    }\n}\n/**\n * Handle notification click events\n */ async function handleNotificationClick(action, data) {\n    try {\n        console.log(\"Handling notification click:\", {\n            action,\n            data\n        });\n        // Track click event\n        await trackNotificationEvent(\"clicked\", {\n            ...data,\n            action\n        });\n        // Handle specific actions\n        await openNotificationUrl(data);\n    } catch (error) {\n        console.error(\"Error handling notification click:\", error);\n    }\n}\n/**\n * Open notification URL in client\n */ async function openNotificationUrl(data) {\n    try {\n        const url = data.url || getNotificationUrl(data.notificationType, data);\n        console.log(\"Opening notification URL:\", url);\n        // Focus existing window or open new one\n        const clients = await self.clients.matchAll({\n            type: \"window\"\n        });\n        for (const client of clients){\n            if (client.url.includes(url) && \"focus\" in client) {\n                return client.focus();\n            }\n        }\n        // Open new window\n        if (self.clients.openWindow) {\n            return self.clients.openWindow(url);\n        }\n    } catch (error) {\n        console.error(\"Error opening notification URL:\", error);\n    }\n}\n/**\n * Get notification URL based on type and data\n */ function getNotificationUrl(notificationType) {\n    let data = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    if (data.actionUrl) {\n        return data.actionUrl;\n    }\n    const baseUrl = NOTIFICATION_URLS[notificationType] || \"/dashboard\";\n    // Add specific IDs if available\n    if (data.appointmentId && baseUrl.includes(\"appointments\")) {\n        return \"\".concat(baseUrl, \"/\").concat(data.appointmentId);\n    }\n    if (data.prescriptionId && baseUrl.includes(\"prescriptions\")) {\n        return \"\".concat(baseUrl, \"/\").concat(data.prescriptionId);\n    }\n    return baseUrl;\n}\n/**\n * Track notification events for analytics\n */ async function trackNotificationEvent(event, data) {\n    try {\n        console.log(\"Tracking notification event:\", {\n            event,\n            data\n        });\n        // Store event locally\n        const eventData = {\n            event,\n            notificationType: data.notificationType,\n            timestamp: Date.now(),\n            userId: data.userId,\n            appointmentId: data.appointmentId,\n            prescriptionId: data.prescriptionId,\n            action: data.action\n        };\n        // Store in IndexedDB or localStorage\n        await storeNotificationEvent(eventData);\n        // Try to send to backend (with background sync fallback)\n        try {\n            await sendEventToBackend(eventData);\n        } catch (error) {\n            console.log(\"Failed to send event to backend, will retry later:\", error);\n        // Could implement background sync here\n        }\n    } catch (error) {\n        console.error(\"Error tracking notification event:\", error);\n    }\n}\n/**\n * Store notification event locally\n */ async function storeNotificationEvent(eventData) {\n    try {\n        // For simplicity, using cache API to store events\n        // In production, you might want to use IndexedDB\n        const cache = await caches.open(CACHE_NAME);\n        const eventKey = \"event-\".concat(eventData.timestamp);\n        const response = new Response(JSON.stringify(eventData), {\n            headers: {\n                \"Content-Type\": \"application/json\"\n            }\n        });\n        await cache.put(eventKey, response);\n        console.log(\"Notification event stored locally\");\n    } catch (error) {\n        console.error(\"Error storing notification event:\", error);\n    }\n}\n/**\n * Send event to backend\n */ async function sendEventToBackend(eventData) {\n    try {\n        const response = await fetch(\"\".concat(API_BASE_URL, \"/api/notification-events\"), {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify(eventData)\n        });\n        if (!response.ok) {\n            throw new Error(\"HTTP \".concat(response.status, \": \").concat(response.statusText));\n        }\n        console.log(\"Event sent to backend successfully\");\n    } catch (error) {\n        console.error(\"Error sending event to backend:\", error);\n        throw error;\n    }\n}\n/**\n * Background sync for offline events (optional)\n */ self.addEventListener(\"sync\", (event)=>{\n    if (event.tag === \"notification-events-sync\") {\n        console.log(\"Background sync triggered for notification events\");\n        event.waitUntil(syncNotificationEvents());\n    }\n});\n/**\n * Sync stored notification events when online\n */ async function syncNotificationEvents() {\n    try {\n        const cache = await caches.open(CACHE_NAME);\n        const keys = await cache.keys();\n        for (const request of keys){\n            if (request.url.includes(\"event-\")) {\n                try {\n                    const response = await cache.match(request);\n                    const eventData = await response.json();\n                    await sendEventToBackend(eventData);\n                    await cache.delete(request);\n                    console.log(\"Synced notification event:\", eventData.event);\n                } catch (error) {\n                    console.error(\"Error syncing event:\", error);\n                }\n            }\n        }\n    } catch (error) {\n        console.error(\"Error during notification events sync:\", error);\n    }\n}\n/**\n * Clean up old notification events\n */ self.addEventListener(\"activate\", (event)=>{\n    event.waitUntil(cleanupOldEvents());\n});\nasync function cleanupOldEvents() {\n    try {\n        const cache = await caches.open(CACHE_NAME);\n        const keys = await cache.keys();\n        const oneWeekAgo = Date.now() - 7 * 24 * 60 * 60 * 1000;\n        for (const request of keys){\n            if (request.url.includes(\"event-\")) {\n                const timestamp = parseInt(request.url.split(\"event-\")[1]);\n                if (timestamp < oneWeekAgo) {\n                    await cache.delete(request);\n                }\n            }\n        }\n        console.log(\"Cleaned up old notification events\");\n    } catch (error) {\n        console.error(\"Error cleaning up old events:\", error);\n    }\n}\nconsole.log(\"MyTelmed Push Notification Service Worker loaded\");\n// Export functions for testing\nif ( true && module.exports) {\n    module.exports = {\n        showNotification,\n        handleNotificationClick,\n        getNotificationUrl,\n        trackNotificationEvent\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                /* unsupported import.meta.webpackHot */ undefined.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LFNBQVNMLFFBQVF6QyxHQUFHLENBQUMrQyxLQUFLLENBQUMsU0FBUyxDQUFDLEVBQUU7Z0JBQ3pELElBQUloRCxZQUFZOEMsWUFBWTtvQkFDeEIsTUFBTXRCLE1BQU1vQixNQUFNLENBQUNGO2dCQUN2QjtZQUNKO1FBQ0o7UUFFQS9GLFFBQVFDLEdBQUcsQ0FBQztJQUNoQixFQUFFLE9BQU9nQyxPQUFPO1FBQ1pqQyxRQUFRaUMsS0FBSyxDQUFDLGlDQUFpQ0E7SUFDbkQ7QUFDSjtBQUVBakMsUUFBUUMsR0FBRyxDQUFDO0FBRVosK0JBQStCO0FBQy9CLElBQUksS0FBNkIsSUFBSXFHLE9BQU9DLE9BQU8sRUFBRTtJQUNqREQsT0FBT0MsT0FBTyxHQUFHO1FBQ2JwRTtRQUNBSztRQUNBZTtRQUNBZDtJQUNKO0FBQ0oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vcHVibGljL3N3LXB1c2guanM/OWYwMyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIE15VGVsbWVkIFB1c2ggTm90aWZpY2F0aW9uIFNlcnZpY2UgV29ya2VyXG4gKiBIYW5kbGVzIHB1c2ggZXZlbnRzLCBub3RpZmljYXRpb24gY2xpY2tzLCBhbmQgYmFja2dyb3VuZCBzeW5jXG4gKi9cblxuLy8gV29ya2JveCBtYW5pZmVzdCBpbmplY3Rpb24gLSByZXF1aXJlZCBmb3IgUFdBIGNhY2hpbmdcbmltcG9ydFNjcmlwdHMoXCJodHRwczovL3N0b3JhZ2UuZ29vZ2xlYXBpcy5jb20vd29ya2JveC1jZG4vcmVsZWFzZXMvNi40LjEvd29ya2JveC1zdy5qc1wiKTtcblxuLy8gSW5qZWN0IHRoZSBtYW5pZmVzdCAtIHRoaXMgd2lsbCBiZSByZXBsYWNlZCBieSBXb3JrYm94IGR1cmluZyBidWlsZFxuaWYgKHR5cGVvZiBzZWxmLl9fV0JfTUFOSUZFU1QgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAvLyBUaGlzIGVuc3VyZXMgdGhlIG1hbmlmZXN0IGlzIGluY2x1ZGVkIGluIHRoZSBzZXJ2aWNlIHdvcmtlclxuICAgIGNvbnNvbGUubG9nKFwiV29ya2JveCBtYW5pZmVzdCBsb2FkZWRcIik7XG59XG5cbi8vIENvbnN0YW50c1xuY29uc3QgTk9USUZJQ0FUSU9OX1RBR19QUkVGSVggPSBcIm15dGVsbWVkLVwiO1xuY29uc3QgQ0FDSEVfTkFNRSA9IFwibXl0ZWxtZWQtbm90aWZpY2F0aW9ucy12MVwiO1xuY29uc3QgQVBJX0JBU0VfVVJMID0gc2VsZi5sb2NhdGlvbi5vcmlnaW47XG5jb25zdCBGQUxMQkFDS19JQ09OID0gXCIvYXNzZXRzL2xvZ29zL215dGVsbWVkLWxvZ28ucG5nXCI7XG5jb25zdCBGQUxMQkFDS19CQURHRSA9IFwiL2Fzc2V0cy9sb2dvcy9teXRlbG1lZC1sb2dvLnBuZ1wiO1xuXG4vLyBOb3RpZmljYXRpb24gYWN0aW9uIGhhbmRsZXJzXG5jb25zdCBOT1RJRklDQVRJT05fQUNUSU9OUyA9IHtcbiAgICB2aWV3OiBcIlZpZXcgRGV0YWlsc1wiLFxuICAgIGRpc21pc3M6IFwiRGlzbWlzc1wiLFxuICAgIGNhbGVuZGFyOiBcIkFkZCB0byBDYWxlbmRhclwiLFxuICAgIG9yZGVyOiBcIk9yZGVyIE5vd1wiLFxuICAgIHJlbmV3OiBcIlJlbmV3IE5vd1wiLFxuICAgIHJlbWluZDogXCJSZW1pbmQgTGF0ZXJcIixcbiAgICB0cmFjazogXCJUcmFjayBEZWxpdmVyeVwiLFxuICAgIGNvbnRhY3Q6IFwiQ29udGFjdCBTdXBwb3J0XCIsXG59O1xuXG4vLyBVUkwgbWFwcGluZ3MgZm9yIGRpZmZlcmVudCBub3RpZmljYXRpb24gdHlwZXNcbmNvbnN0IE5PVElGSUNBVElPTl9VUkxTID0ge1xuICAgIEFQUE9JTlRNRU5UX1JFTUlOREVSX1BBVElFTlQ6IFwiL2FwcG9pbnRtZW50c1wiLFxuICAgIEFQUE9JTlRNRU5UX0NPTkZJUk1BVElPTl9QQVRJRU5UOiBcIi9hcHBvaW50bWVudHNcIixcbiAgICBBUFBPSU5UTUVOVF9DQU5DRUxfUEFUSUVOVDogXCIvYXBwb2ludG1lbnRzXCIsXG4gICAgQVBQT0lOVE1FTlRfQk9PS0VEX1BBVElFTlQ6IFwiL2FwcG9pbnRtZW50c1wiLFxuICAgIFBSRVNDUklQVElPTl9DUkVBVEVEOiBcIi9wcmVzY3JpcHRpb25zXCIsXG4gICAgUFJFU0NSSVBUSU9OX0VYUElSSU5HOiBcIi9wcmVzY3JpcHRpb25zXCIsXG4gICAgUFJFU0NSSVBUSU9OX09VVF9GT1JfREVMSVZFUlk6IFwiL3ByZXNjcmlwdGlvbnMvZGVsaXZlcnlcIixcbn07XG5cbi8qKlxuICogUHVzaCBldmVudCBoYW5kbGVyIC0gcmVjZWl2ZXMgbm90aWZpY2F0aW9ucyBmcm9tIGJhY2tlbmRcbiAqL1xuc2VsZi5hZGRFdmVudExpc3RlbmVyKFwicHVzaFwiLCAoZXZlbnQpID0+IHtcbiAgICBjb25zb2xlLmxvZyhcIlB1c2ggbm90aWZpY2F0aW9uIHJlY2VpdmVkOlwiLCBldmVudCk7XG5cbiAgICBpZiAoIWV2ZW50LmRhdGEpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJQdXNoIGV2ZW50IGhhcyBubyBkYXRhXCIpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgICAgLy8gUGFyc2Ugbm90aWZpY2F0aW9uIHBheWxvYWRcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IGV2ZW50LmRhdGEuanNvbigpO1xuICAgICAgICBjb25zb2xlLmxvZyhcIlB1c2ggcGF5bG9hZDpcIiwgcGF5bG9hZCk7XG5cbiAgICAgICAgLy8gVmFsaWRhdGUgcGF5bG9hZFxuICAgICAgICBpZiAoIXBheWxvYWQudGl0bGUgfHwgIXBheWxvYWQuYm9keSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkludmFsaWQgcHVzaCBwYXlsb2FkIC0gbWlzc2luZyB0aXRsZSBvciBib2R5XCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2hvdyBub3RpZmljYXRpb25cbiAgICAgICAgZXZlbnQud2FpdFVudGlsKHNob3dOb3RpZmljYXRpb24ocGF5bG9hZCkpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBwcm9jZXNzaW5nIHB1c2ggZXZlbnQ6XCIsIGVycm9yKTtcblxuICAgICAgICAvLyBTaG93IGZhbGxiYWNrIG5vdGlmaWNhdGlvblxuICAgICAgICBldmVudC53YWl0VW50aWwoc2hvd0ZhbGxiYWNrTm90aWZpY2F0aW9uKFwiTXlUZWxtZWQgTm90aWZpY2F0aW9uXCIsIFwiWW91IGhhdmUgYSBuZXcgbm90aWZpY2F0aW9uXCIpKTtcbiAgICB9XG59KTtcblxuLyoqXG4gKiBOb3RpZmljYXRpb24gY2xpY2sgaGFuZGxlclxuICovXG5zZWxmLmFkZEV2ZW50TGlzdGVuZXIoXCJub3RpZmljYXRpb25jbGlja1wiLCAoZXZlbnQpID0+IHtcbiAgICBjb25zb2xlLmxvZyhcIk5vdGlmaWNhdGlvbiBjbGlja2VkOlwiLCBldmVudCk7XG5cbiAgICBjb25zdCBub3RpZmljYXRpb24gPSBldmVudC5ub3RpZmljYXRpb247XG4gICAgY29uc3QgYWN0aW9uID0gZXZlbnQuYWN0aW9uO1xuICAgIGNvbnN0IGRhdGEgPSBub3RpZmljYXRpb24uZGF0YSB8fCB7fTtcblxuICAgIC8vIENsb3NlIHRoZSBub3RpZmljYXRpb25cbiAgICBub3RpZmljYXRpb24uY2xvc2UoKTtcblxuICAgIC8vIEhhbmRsZSBkaWZmZXJlbnQgYWN0aW9uc1xuICAgIGV2ZW50LndhaXRVbnRpbChoYW5kbGVOb3RpZmljYXRpb25DbGljayhhY3Rpb24sIGRhdGEpKTtcbn0pO1xuXG4vKipcbiAqIE5vdGlmaWNhdGlvbiBjbG9zZSBoYW5kbGVyXG4gKi9cbnNlbGYuYWRkRXZlbnRMaXN0ZW5lcihcIm5vdGlmaWNhdGlvbmNsb3NlXCIsIChldmVudCkgPT4ge1xuICAgIGNvbnNvbGUubG9nKFwiTm90aWZpY2F0aW9uIGNsb3NlZDpcIiwgZXZlbnQpO1xuXG4gICAgY29uc3QgZGF0YSA9IGV2ZW50Lm5vdGlmaWNhdGlvbi5kYXRhIHx8IHt9O1xuXG4gICAgLy8gVHJhY2sgbm90aWZpY2F0aW9uIGRpc21pc3NhbFxuICAgIGV2ZW50LndhaXRVbnRpbCh0cmFja05vdGlmaWNhdGlvbkV2ZW50KFwiZGlzbWlzc2VkXCIsIGRhdGEpKTtcbn0pO1xuXG4vKipcbiAqIFNob3cgbm90aWZpY2F0aW9uIHdpdGggcHJvcGVyIGZvcm1hdHRpbmdcbiAqL1xuYXN5bmMgZnVuY3Rpb24gc2hvd05vdGlmaWNhdGlvbihwYXlsb2FkKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgdGl0bGUsXG4gICAgICAgICAgICBib2R5LFxuICAgICAgICAgICAgaWNvbiA9IEZBTExCQUNLX0lDT04sXG4gICAgICAgICAgICBiYWRnZSA9IEZBTExCQUNLX0JBREdFLFxuICAgICAgICAgICAgaW1hZ2UsXG4gICAgICAgICAgICB0YWcsXG4gICAgICAgICAgICBkYXRhID0ge30sXG4gICAgICAgICAgICBhY3Rpb25zID0gW10sXG4gICAgICAgICAgICByZXF1aXJlSW50ZXJhY3Rpb24gPSBmYWxzZSxcbiAgICAgICAgICAgIHNpbGVudCA9IGZhbHNlLFxuICAgICAgICAgICAgdmlicmF0ZSA9IFsyMDAsIDEwMCwgMjAwXSxcbiAgICAgICAgfSA9IHBheWxvYWQ7XG5cbiAgICAgICAgLy8gQ3JlYXRlIG5vdGlmaWNhdGlvbiBvcHRpb25zXG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgICAgICBib2R5LFxuICAgICAgICAgICAgaWNvbixcbiAgICAgICAgICAgIGJhZGdlLFxuICAgICAgICAgICAgaW1hZ2UsXG4gICAgICAgICAgICB0YWc6IHRhZyB8fCBgJHtOT1RJRklDQVRJT05fVEFHX1BSRUZJWH0ke0RhdGUubm93KCl9YCxcbiAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAuLi5kYXRhLFxuICAgICAgICAgICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcbiAgICAgICAgICAgICAgICB1cmw6IGdldE5vdGlmaWNhdGlvblVybChkYXRhLm5vdGlmaWNhdGlvblR5cGUsIGRhdGEpLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFjdGlvbnM6IGFjdGlvbnMubWFwKChhY3Rpb24pID0+ICh7XG4gICAgICAgICAgICAgICAgYWN0aW9uOiBhY3Rpb24uYWN0aW9uLFxuICAgICAgICAgICAgICAgIHRpdGxlOiBOT1RJRklDQVRJT05fQUNUSU9OU1thY3Rpb24uYWN0aW9uXSB8fCBhY3Rpb24udGl0bGUsXG4gICAgICAgICAgICAgICAgaWNvbjogYWN0aW9uLmljb24sXG4gICAgICAgICAgICB9KSksXG4gICAgICAgICAgICByZXF1aXJlSW50ZXJhY3Rpb24sXG4gICAgICAgICAgICBzaWxlbnQsXG4gICAgICAgICAgICB2aWJyYXRlOiBzaWxlbnQgPyBbXSA6IHZpYnJhdGUsXG4gICAgICAgICAgICByZW5vdGlmeTogdHJ1ZSxcbiAgICAgICAgICAgIHBlcnNpc3RlbnQ6IHRydWUsXG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc29sZS5sb2coXCJTaG93aW5nIG5vdGlmaWNhdGlvbiB3aXRoIG9wdGlvbnM6XCIsIG9wdGlvbnMpO1xuXG4gICAgICAgIC8vIFNob3cgdGhlIG5vdGlmaWNhdGlvblxuICAgICAgICBhd2FpdCBzZWxmLnJlZ2lzdHJhdGlvbi5zaG93Tm90aWZpY2F0aW9uKHRpdGxlLCBvcHRpb25zKTtcblxuICAgICAgICAvLyBUcmFjayBub3RpZmljYXRpb24gZGVsaXZlcnlcbiAgICAgICAgYXdhaXQgdHJhY2tOb3RpZmljYXRpb25FdmVudChcImRlbGl2ZXJlZFwiLCBkYXRhKTtcblxuICAgICAgICBjb25zb2xlLmxvZyhcIk5vdGlmaWNhdGlvbiBzaG93biBzdWNjZXNzZnVsbHlcIik7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIHNob3dpbmcgbm90aWZpY2F0aW9uOlwiLCBlcnJvcik7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbn1cblxuLyoqXG4gKiBTaG93IGZhbGxiYWNrIG5vdGlmaWNhdGlvbiB3aGVuIHBheWxvYWQgaXMgaW52YWxpZFxuICovXG5hc3luYyBmdW5jdGlvbiBzaG93RmFsbGJhY2tOb3RpZmljYXRpb24odGl0bGUsIGJvZHkpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICAgICAgYm9keSxcbiAgICAgICAgICAgIGljb246IEZBTExCQUNLX0lDT04sXG4gICAgICAgICAgICBiYWRnZTogRkFMTEJBQ0tfQkFER0UsXG4gICAgICAgICAgICB0YWc6IGAke05PVElGSUNBVElPTl9UQUdfUFJFRklYfWZhbGxiYWNrYCxcbiAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IERhdGUubm93KCksXG4gICAgICAgICAgICAgICAgdHlwZTogXCJmYWxsYmFja1wiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlcXVpcmVJbnRlcmFjdGlvbjogZmFsc2UsXG4gICAgICAgIH07XG5cbiAgICAgICAgYXdhaXQgc2VsZi5yZWdpc3RyYXRpb24uc2hvd05vdGlmaWNhdGlvbih0aXRsZSwgb3B0aW9ucyk7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiRmFsbGJhY2sgbm90aWZpY2F0aW9uIHNob3duXCIpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBzaG93aW5nIGZhbGxiYWNrIG5vdGlmaWNhdGlvbjpcIiwgZXJyb3IpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBIYW5kbGUgbm90aWZpY2F0aW9uIGNsaWNrIGV2ZW50c1xuICovXG5hc3luYyBmdW5jdGlvbiBoYW5kbGVOb3RpZmljYXRpb25DbGljayhhY3Rpb24sIGRhdGEpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zb2xlLmxvZyhcIkhhbmRsaW5nIG5vdGlmaWNhdGlvbiBjbGljazpcIiwgeyBhY3Rpb24sIGRhdGEgfSk7XG5cbiAgICAgICAgLy8gVHJhY2sgY2xpY2sgZXZlbnRcbiAgICAgICAgYXdhaXQgdHJhY2tOb3RpZmljYXRpb25FdmVudChcImNsaWNrZWRcIiwgeyAuLi5kYXRhLCBhY3Rpb24gfSk7XG5cbiAgICAgICAgLy8gSGFuZGxlIHNwZWNpZmljIGFjdGlvbnNcbiAgICAgICAgYXdhaXQgb3Blbk5vdGlmaWNhdGlvblVybChkYXRhKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgaGFuZGxpbmcgbm90aWZpY2F0aW9uIGNsaWNrOlwiLCBlcnJvcik7XG4gICAgfVxufVxuXG4vKipcbiAqIE9wZW4gbm90aWZpY2F0aW9uIFVSTCBpbiBjbGllbnRcbiAqL1xuYXN5bmMgZnVuY3Rpb24gb3Blbk5vdGlmaWNhdGlvblVybChkYXRhKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgdXJsID0gZGF0YS51cmwgfHwgZ2V0Tm90aWZpY2F0aW9uVXJsKGRhdGEubm90aWZpY2F0aW9uVHlwZSwgZGF0YSk7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiT3BlbmluZyBub3RpZmljYXRpb24gVVJMOlwiLCB1cmwpO1xuXG4gICAgICAgIC8vIEZvY3VzIGV4aXN0aW5nIHdpbmRvdyBvciBvcGVuIG5ldyBvbmVcbiAgICAgICAgY29uc3QgY2xpZW50cyA9IGF3YWl0IHNlbGYuY2xpZW50cy5tYXRjaEFsbCh7IHR5cGU6IFwid2luZG93XCIgfSk7XG5cbiAgICAgICAgZm9yIChjb25zdCBjbGllbnQgb2YgY2xpZW50cykge1xuICAgICAgICAgICAgaWYgKGNsaWVudC51cmwuaW5jbHVkZXModXJsKSAmJiBcImZvY3VzXCIgaW4gY2xpZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNsaWVudC5mb2N1cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gT3BlbiBuZXcgd2luZG93XG4gICAgICAgIGlmIChzZWxmLmNsaWVudHMub3BlbldpbmRvdykge1xuICAgICAgICAgICAgcmV0dXJuIHNlbGYuY2xpZW50cy5vcGVuV2luZG93KHVybCk7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3Igb3BlbmluZyBub3RpZmljYXRpb24gVVJMOlwiLCBlcnJvcik7XG4gICAgfVxufVxuXG4vKipcbiAqIEdldCBub3RpZmljYXRpb24gVVJMIGJhc2VkIG9uIHR5cGUgYW5kIGRhdGFcbiAqL1xuZnVuY3Rpb24gZ2V0Tm90aWZpY2F0aW9uVXJsKG5vdGlmaWNhdGlvblR5cGUsIGRhdGEgPSB7fSkge1xuICAgIGlmIChkYXRhLmFjdGlvblVybCkge1xuICAgICAgICByZXR1cm4gZGF0YS5hY3Rpb25Vcmw7XG4gICAgfVxuXG4gICAgY29uc3QgYmFzZVVybCA9IE5PVElGSUNBVElPTl9VUkxTW25vdGlmaWNhdGlvblR5cGVdIHx8IFwiL2Rhc2hib2FyZFwiO1xuXG4gICAgLy8gQWRkIHNwZWNpZmljIElEcyBpZiBhdmFpbGFibGVcbiAgICBpZiAoZGF0YS5hcHBvaW50bWVudElkICYmIGJhc2VVcmwuaW5jbHVkZXMoXCJhcHBvaW50bWVudHNcIikpIHtcbiAgICAgICAgcmV0dXJuIGAke2Jhc2VVcmx9LyR7ZGF0YS5hcHBvaW50bWVudElkfWA7XG4gICAgfVxuXG4gICAgaWYgKGRhdGEucHJlc2NyaXB0aW9uSWQgJiYgYmFzZVVybC5pbmNsdWRlcyhcInByZXNjcmlwdGlvbnNcIikpIHtcbiAgICAgICAgcmV0dXJuIGAke2Jhc2VVcmx9LyR7ZGF0YS5wcmVzY3JpcHRpb25JZH1gO1xuICAgIH1cblxuICAgIHJldHVybiBiYXNlVXJsO1xufVxuXG4vKipcbiAqIFRyYWNrIG5vdGlmaWNhdGlvbiBldmVudHMgZm9yIGFuYWx5dGljc1xuICovXG5hc3luYyBmdW5jdGlvbiB0cmFja05vdGlmaWNhdGlvbkV2ZW50KGV2ZW50LCBkYXRhKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc29sZS5sb2coXCJUcmFja2luZyBub3RpZmljYXRpb24gZXZlbnQ6XCIsIHsgZXZlbnQsIGRhdGEgfSk7XG5cbiAgICAgICAgLy8gU3RvcmUgZXZlbnQgbG9jYWxseVxuICAgICAgICBjb25zdCBldmVudERhdGEgPSB7XG4gICAgICAgICAgICBldmVudCxcbiAgICAgICAgICAgIG5vdGlmaWNhdGlvblR5cGU6IGRhdGEubm90aWZpY2F0aW9uVHlwZSxcbiAgICAgICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcbiAgICAgICAgICAgIHVzZXJJZDogZGF0YS51c2VySWQsXG4gICAgICAgICAgICBhcHBvaW50bWVudElkOiBkYXRhLmFwcG9pbnRtZW50SWQsXG4gICAgICAgICAgICBwcmVzY3JpcHRpb25JZDogZGF0YS5wcmVzY3JpcHRpb25JZCxcbiAgICAgICAgICAgIGFjdGlvbjogZGF0YS5hY3Rpb24sXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gU3RvcmUgaW4gSW5kZXhlZERCIG9yIGxvY2FsU3RvcmFnZVxuICAgICAgICBhd2FpdCBzdG9yZU5vdGlmaWNhdGlvbkV2ZW50KGV2ZW50RGF0YSk7XG5cbiAgICAgICAgLy8gVHJ5IHRvIHNlbmQgdG8gYmFja2VuZCAod2l0aCBiYWNrZ3JvdW5kIHN5bmMgZmFsbGJhY2spXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCBzZW5kRXZlbnRUb0JhY2tlbmQoZXZlbnREYXRhKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiRmFpbGVkIHRvIHNlbmQgZXZlbnQgdG8gYmFja2VuZCwgd2lsbCByZXRyeSBsYXRlcjpcIiwgZXJyb3IpO1xuICAgICAgICAgICAgLy8gQ291bGQgaW1wbGVtZW50IGJhY2tncm91bmQgc3luYyBoZXJlXG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgdHJhY2tpbmcgbm90aWZpY2F0aW9uIGV2ZW50OlwiLCBlcnJvcik7XG4gICAgfVxufVxuXG4vKipcbiAqIFN0b3JlIG5vdGlmaWNhdGlvbiBldmVudCBsb2NhbGx5XG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHN0b3JlTm90aWZpY2F0aW9uRXZlbnQoZXZlbnREYXRhKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gRm9yIHNpbXBsaWNpdHksIHVzaW5nIGNhY2hlIEFQSSB0byBzdG9yZSBldmVudHNcbiAgICAgICAgLy8gSW4gcHJvZHVjdGlvbiwgeW91IG1pZ2h0IHdhbnQgdG8gdXNlIEluZGV4ZWREQlxuICAgICAgICBjb25zdCBjYWNoZSA9IGF3YWl0IGNhY2hlcy5vcGVuKENBQ0hFX05BTUUpO1xuICAgICAgICBjb25zdCBldmVudEtleSA9IGBldmVudC0ke2V2ZW50RGF0YS50aW1lc3RhbXB9YDtcblxuICAgICAgICBjb25zdCByZXNwb25zZSA9IG5ldyBSZXNwb25zZShKU09OLnN0cmluZ2lmeShldmVudERhdGEpLCB7XG4gICAgICAgICAgICBoZWFkZXJzOiB7IFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH0sXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGF3YWl0IGNhY2hlLnB1dChldmVudEtleSwgcmVzcG9uc2UpO1xuICAgICAgICBjb25zb2xlLmxvZyhcIk5vdGlmaWNhdGlvbiBldmVudCBzdG9yZWQgbG9jYWxseVwiKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3Igc3RvcmluZyBub3RpZmljYXRpb24gZXZlbnQ6XCIsIGVycm9yKTtcbiAgICB9XG59XG5cbi8qKlxuICogU2VuZCBldmVudCB0byBiYWNrZW5kXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHNlbmRFdmVudFRvQmFja2VuZChldmVudERhdGEpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke0FQSV9CQVNFX1VSTH0vYXBpL25vdGlmaWNhdGlvbi1ldmVudHNgLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGV2ZW50RGF0YSksXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSFRUUCAke3Jlc3BvbnNlLnN0YXR1c306ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnNvbGUubG9nKFwiRXZlbnQgc2VudCB0byBiYWNrZW5kIHN1Y2Nlc3NmdWxseVwiKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3Igc2VuZGluZyBldmVudCB0byBiYWNrZW5kOlwiLCBlcnJvcik7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbn1cblxuLyoqXG4gKiBCYWNrZ3JvdW5kIHN5bmMgZm9yIG9mZmxpbmUgZXZlbnRzIChvcHRpb25hbClcbiAqL1xuc2VsZi5hZGRFdmVudExpc3RlbmVyKFwic3luY1wiLCAoZXZlbnQpID0+IHtcbiAgICBpZiAoZXZlbnQudGFnID09PSBcIm5vdGlmaWNhdGlvbi1ldmVudHMtc3luY1wiKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiQmFja2dyb3VuZCBzeW5jIHRyaWdnZXJlZCBmb3Igbm90aWZpY2F0aW9uIGV2ZW50c1wiKTtcbiAgICAgICAgZXZlbnQud2FpdFVudGlsKHN5bmNOb3RpZmljYXRpb25FdmVudHMoKSk7XG4gICAgfVxufSk7XG5cbi8qKlxuICogU3luYyBzdG9yZWQgbm90aWZpY2F0aW9uIGV2ZW50cyB3aGVuIG9ubGluZVxuICovXG5hc3luYyBmdW5jdGlvbiBzeW5jTm90aWZpY2F0aW9uRXZlbnRzKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGNhY2hlID0gYXdhaXQgY2FjaGVzLm9wZW4oQ0FDSEVfTkFNRSk7XG4gICAgICAgIGNvbnN0IGtleXMgPSBhd2FpdCBjYWNoZS5rZXlzKCk7XG5cbiAgICAgICAgZm9yIChjb25zdCByZXF1ZXN0IG9mIGtleXMpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0LnVybC5pbmNsdWRlcyhcImV2ZW50LVwiKSkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY2FjaGUubWF0Y2gocmVxdWVzdCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGV2ZW50RGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcblxuICAgICAgICAgICAgICAgICAgICBhd2FpdCBzZW5kRXZlbnRUb0JhY2tlbmQoZXZlbnREYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgY2FjaGUuZGVsZXRlKHJlcXVlc3QpO1xuXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiU3luY2VkIG5vdGlmaWNhdGlvbiBldmVudDpcIiwgZXZlbnREYXRhLmV2ZW50KTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3Igc3luY2luZyBldmVudDpcIiwgZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBkdXJpbmcgbm90aWZpY2F0aW9uIGV2ZW50cyBzeW5jOlwiLCBlcnJvcik7XG4gICAgfVxufVxuXG4vKipcbiAqIENsZWFuIHVwIG9sZCBub3RpZmljYXRpb24gZXZlbnRzXG4gKi9cbnNlbGYuYWRkRXZlbnRMaXN0ZW5lcihcImFjdGl2YXRlXCIsIChldmVudCkgPT4ge1xuICAgIGV2ZW50LndhaXRVbnRpbChjbGVhbnVwT2xkRXZlbnRzKCkpO1xufSk7XG5cbmFzeW5jIGZ1bmN0aW9uIGNsZWFudXBPbGRFdmVudHMoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgY2FjaGUgPSBhd2FpdCBjYWNoZXMub3BlbihDQUNIRV9OQU1FKTtcbiAgICAgICAgY29uc3Qga2V5cyA9IGF3YWl0IGNhY2hlLmtleXMoKTtcbiAgICAgICAgY29uc3Qgb25lV2Vla0FnbyA9IERhdGUubm93KCkgLSA3ICogMjQgKiA2MCAqIDYwICogMTAwMDtcblxuICAgICAgICBmb3IgKGNvbnN0IHJlcXVlc3Qgb2Yga2V5cykge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3QudXJsLmluY2x1ZGVzKFwiZXZlbnQtXCIpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGltZXN0YW1wID0gcGFyc2VJbnQocmVxdWVzdC51cmwuc3BsaXQoXCJldmVudC1cIilbMV0pO1xuICAgICAgICAgICAgICAgIGlmICh0aW1lc3RhbXAgPCBvbmVXZWVrQWdvKSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IGNhY2hlLmRlbGV0ZShyZXF1ZXN0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zb2xlLmxvZyhcIkNsZWFuZWQgdXAgb2xkIG5vdGlmaWNhdGlvbiBldmVudHNcIik7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGNsZWFuaW5nIHVwIG9sZCBldmVudHM6XCIsIGVycm9yKTtcbiAgICB9XG59XG5cbmNvbnNvbGUubG9nKFwiTXlUZWxtZWQgUHVzaCBOb3RpZmljYXRpb24gU2VydmljZSBXb3JrZXIgbG9hZGVkXCIpO1xuXG4vLyBFeHBvcnQgZnVuY3Rpb25zIGZvciB0ZXN0aW5nXG5pZiAodHlwZW9mIG1vZHVsZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgIG1vZHVsZS5leHBvcnRzID0ge1xuICAgICAgICBzaG93Tm90aWZpY2F0aW9uLFxuICAgICAgICBoYW5kbGVOb3RpZmljYXRpb25DbGljayxcbiAgICAgICAgZ2V0Tm90aWZpY2F0aW9uVXJsLFxuICAgICAgICB0cmFja05vdGlmaWNhdGlvbkV2ZW50LFxuICAgIH07XG59XG4iXSwibmFtZXMiOlsiaW1wb3J0U2NyaXB0cyIsInNlbGYiLCJfX1dCX01BTklGRVNUIiwiY29uc29sZSIsImxvZyIsIk5PVElGSUNBVElPTl9UQUdfUFJFRklYIiwiQ0FDSEVfTkFNRSIsIkFQSV9CQVNFX1VSTCIsImxvY2F0aW9uIiwib3JpZ2luIiwiRkFMTEJBQ0tfSUNPTiIsIkZBTExCQUNLX0JBREdFIiwiTk9USUZJQ0FUSU9OX0FDVElPTlMiLCJ2aWV3IiwiZGlzbWlzcyIsImNhbGVuZGFyIiwib3JkZXIiLCJyZW5ldyIsInJlbWluZCIsInRyYWNrIiwiY29udGFjdCIsIk5PVElGSUNBVElPTl9VUkxTIiwiQVBQT0lOVE1FTlRfUkVNSU5ERVJfUEFUSUVOVCIsIkFQUE9JTlRNRU5UX0NPTkZJUk1BVElPTl9QQVRJRU5UIiwiQVBQT0lOVE1FTlRfQ0FOQ0VMX1BBVElFTlQiLCJBUFBPSU5UTUVOVF9CT09LRURfUEFUSUVOVCIsIlBSRVNDUklQVElPTl9DUkVBVEVEIiwiUFJFU0NSSVBUSU9OX0VYUElSSU5HIiwiUFJFU0NSSVBUSU9OX09VVF9GT1JfREVMSVZFUlkiLCJhZGRFdmVudExpc3RlbmVyIiwiZXZlbnQiLCJkYXRhIiwicGF5bG9hZCIsImpzb24iLCJ0aXRsZSIsImJvZHkiLCJlcnJvciIsIndhaXRVbnRpbCIsInNob3dOb3RpZmljYXRpb24iLCJzaG93RmFsbGJhY2tOb3RpZmljYXRpb24iLCJub3RpZmljYXRpb24iLCJhY3Rpb24iLCJjbG9zZSIsImhhbmRsZU5vdGlmaWNhdGlvbkNsaWNrIiwidHJhY2tOb3RpZmljYXRpb25FdmVudCIsImljb24iLCJiYWRnZSIsImltYWdlIiwidGFnIiwiYWN0aW9ucyIsInJlcXVpcmVJbnRlcmFjdGlvbiIsInNpbGVudCIsInZpYnJhdGUiLCJvcHRpb25zIiwiRGF0ZSIsIm5vdyIsInRpbWVzdGFtcCIsInVybCIsImdldE5vdGlmaWNhdGlvblVybCIsIm5vdGlmaWNhdGlvblR5cGUiLCJtYXAiLCJyZW5vdGlmeSIsInBlcnNpc3RlbnQiLCJyZWdpc3RyYXRpb24iLCJ0eXBlIiwib3Blbk5vdGlmaWNhdGlvblVybCIsImNsaWVudHMiLCJtYXRjaEFsbCIsImNsaWVudCIsImluY2x1ZGVzIiwiZm9jdXMiLCJvcGVuV2luZG93IiwiYWN0aW9uVXJsIiwiYmFzZVVybCIsImFwcG9pbnRtZW50SWQiLCJwcmVzY3JpcHRpb25JZCIsImV2ZW50RGF0YSIsInVzZXJJZCIsInN0b3JlTm90aWZpY2F0aW9uRXZlbnQiLCJzZW5kRXZlbnRUb0JhY2tlbmQiLCJjYWNoZSIsImNhY2hlcyIsIm9wZW4iLCJldmVudEtleSIsInJlc3BvbnNlIiwiUmVzcG9uc2UiLCJKU09OIiwic3RyaW5naWZ5IiwiaGVhZGVycyIsInB1dCIsImZldGNoIiwibWV0aG9kIiwib2siLCJFcnJvciIsInN0YXR1cyIsInN0YXR1c1RleHQiLCJzeW5jTm90aWZpY2F0aW9uRXZlbnRzIiwia2V5cyIsInJlcXVlc3QiLCJtYXRjaCIsImRlbGV0ZSIsImNsZWFudXBPbGRFdmVudHMiLCJvbmVXZWVrQWdvIiwicGFyc2VJbnQiLCJzcGxpdCIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./public/sw-push.js\n"));

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			if (cachedModule.error !== undefined) throw cachedModule.error;
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		var threw = true;
/******/ 		try {
/******/ 			__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 			threw = false;
/******/ 		} finally {
/******/ 			if(threw) delete __webpack_module_cache__[moduleId];
/******/ 		}
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/trusted types policy */
/******/ 	!function() {
/******/ 		var policy;
/******/ 		__webpack_require__.tt = function() {
/******/ 			// Create Trusted Type policy if Trusted Types are available and the policy doesn't exist yet.
/******/ 			if (policy === undefined) {
/******/ 				policy = {
/******/ 					createScript: function(script) { return script; }
/******/ 				};
/******/ 				if (typeof trustedTypes !== "undefined" && trustedTypes.createPolicy) {
/******/ 					policy = trustedTypes.createPolicy("nextjs#bundler", policy);
/******/ 				}
/******/ 			}
/******/ 			return policy;
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/trusted types script */
/******/ 	!function() {
/******/ 		__webpack_require__.ts = function(script) { return __webpack_require__.tt().createScript(script); };
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/react refresh */
/******/ 	!function() {
/******/ 		if (__webpack_require__.i) {
/******/ 		__webpack_require__.i.push(function(options) {
/******/ 			var originalFactory = options.factory;
/******/ 			options.factory = function(moduleObject, moduleExports, webpackRequire) {
/******/ 				var hasRefresh = typeof self !== "undefined" && !!self.$RefreshInterceptModuleExecution$;
/******/ 				var cleanup = hasRefresh ? self.$RefreshInterceptModuleExecution$(moduleObject.id) : function() {};
/******/ 				try {
/******/ 					originalFactory.call(this, moduleObject, moduleExports, webpackRequire);
/******/ 				} finally {
/******/ 					cleanup();
/******/ 				}
/******/ 			}
/******/ 		})
/******/ 		}
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/compat */
/******/ 	
/******/ 	
/******/ 	// noop fns to prevent runtime errors during initialization
/******/ 	if (typeof self !== "undefined") {
/******/ 		self.$RefreshReg$ = function () {};
/******/ 		self.$RefreshSig$ = function () {
/******/ 			return function (type) {
/******/ 				return type;
/******/ 			};
/******/ 		};
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./public/sw-push.js");
/******/ 	
/******/ })()
;