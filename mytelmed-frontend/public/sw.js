/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (function() { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./public/sw-push.js":
/*!***************************!*\
  !*** ./public/sw-push.js ***!
  \***************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("/**\r\n * MyTelmed Push Notification Service Worker\r\n * Handles push events, notification clicks, and background sync\r\n */ // Workbox manifest injection - required for PWA caching\n\nimportScripts(\"https://storage.googleapis.com/workbox-cdn/releases/6.4.1/workbox-sw.js\");\n// Inject the manifest - this will be replaced by Workbox during build\nif (typeof [] !== \"undefined\") {\n    // This ensures the manifest is included in the service worker\n    console.log(\"Workbox manifest loaded\");\n}\n// Constants\nconst NOTIFICATION_TAG_PREFIX = \"mytelmed-\";\nconst CACHE_NAME = \"mytelmed-notifications-v1\";\nconst API_BASE_URL = self.location.origin;\nconst FALLBACK_ICON = \"/assets/logos/mytelmed-logo.png\";\nconst FALLBACK_BADGE = \"/assets/logos/mytelmed-logo.png\";\n// URL mappings for different notification types\nconst NOTIFICATION_URLS = {\n    APPOINTMENT_REMINDER_PATIENT: \"/patient/appointment\",\n    APPOINTMENT_CONFIRMATION_PATIENT: \"/patient/appointment\",\n    APPOINTMENT_CANCEL_PATIENT: \"/patient/appointment\",\n    APPOINTMENT_BOOKED_PATIENT: \"/patient/appointment\",\n    PRESCRIPTION_CREATED: \"/patient/prescription\",\n    PRESCRIPTION_EXPIRING: \"/patient/prescription\"\n};\n/**\r\n * Push event handler - receives notifications from backend\r\n */ self.addEventListener(\"push\", (event)=>{\n    console.log(\"Push notification received:\", event);\n    if (!event.data) {\n        console.log(\"Push event has no data\");\n        return;\n    }\n    try {\n        // Parse notification payload\n        const payload = event.data.json();\n        console.log(\"Push payload:\", payload);\n        // Validate payload\n        if (!payload.title || !payload.body) {\n            console.error(\"Invalid push payload - missing title or body\");\n            return;\n        }\n        // Show notification\n        event.waitUntil(showNotification(payload));\n    } catch (error) {\n        console.error(\"Error processing push event:\", error);\n        // Show fallback notification\n        event.waitUntil(showFallbackNotification(\"MyTelmed Notification\", \"You have a new notification\"));\n    }\n});\n/**\r\n * Notification click handler\r\n */ self.addEventListener(\"notificationclick\", (event)=>{\n    console.log(\"Notification clicked:\", event);\n    const notification = event.notification;\n    const action = event.action;\n    const data = notification.data || {};\n    // Close the notification\n    notification.close();\n    // Handle different actions\n    event.waitUntil(handleNotificationClick(action, data));\n});\n/**\r\n * Notification close handler\r\n */ self.addEventListener(\"notificationclose\", (event)=>{\n    console.log(\"Notification closed:\", event);\n    const data = event.notification.data || {};\n    // Track notification dismissal\n    event.waitUntil(trackNotificationEvent(\"dismissed\", data));\n});\n/**\r\n * Show notification with proper formatting\r\n */ async function showNotification(payload) {\n    try {\n        const { title, body, icon = FALLBACK_ICON, badge = FALLBACK_BADGE, image, tag, data = {}, actions = [], requireInteraction = false, silent = false, vibrate = [\n            200,\n            100,\n            200\n        ] } = payload;\n        // Create notification options\n        const options = {\n            body,\n            icon,\n            badge,\n            image,\n            tag: tag || \"\".concat(NOTIFICATION_TAG_PREFIX).concat(Date.now()),\n            data: {\n                ...data,\n                timestamp: Date.now(),\n                url: getNotificationUrl(data.notificationType, data)\n            },\n            actions: actions.map((action)=>({\n                    action: action.action,\n                    title: action.title,\n                    icon: action.icon\n                })),\n            requireInteraction,\n            silent,\n            vibrate: silent ? [] : vibrate,\n            renotify: true,\n            persistent: true\n        };\n        console.log(\"Showing notification with options:\", options);\n        // Show the notification\n        await self.registration.showNotification(title, options);\n        // Track notification delivery\n        await trackNotificationEvent(\"delivered\", data);\n        console.log(\"Notification shown successfully\");\n    } catch (error) {\n        console.error(\"Error showing notification:\", error);\n        throw error;\n    }\n}\n/**\r\n * Show fallback notification when payload is invalid\r\n */ async function showFallbackNotification(title, body) {\n    try {\n        const options = {\n            body,\n            icon: FALLBACK_ICON,\n            badge: FALLBACK_BADGE,\n            tag: \"\".concat(NOTIFICATION_TAG_PREFIX, \"fallback\"),\n            data: {\n                timestamp: Date.now(),\n                type: \"fallback\"\n            },\n            requireInteraction: false\n        };\n        await self.registration.showNotification(title, options);\n        console.log(\"Fallback notification shown\");\n    } catch (error) {\n        console.error(\"Error showing fallback notification:\", error);\n    }\n}\n/**\r\n * Handle notification click events\r\n */ async function handleNotificationClick(action, data) {\n    try {\n        console.log(\"Handling notification click:\", {\n            action,\n            data\n        });\n        // Track click event\n        await trackNotificationEvent(\"clicked\", {\n            ...data,\n            action\n        });\n        // Handle specific actions\n        await openNotificationUrl(data);\n    } catch (error) {\n        console.error(\"Error handling notification click:\", error);\n    }\n}\n/**\r\n * Open notification URL in client\r\n */ async function openNotificationUrl(data) {\n    try {\n        const url = data.url || getNotificationUrl(data.notificationType, data);\n        console.log(\"Opening notification URL:\", url);\n        // Focus existing window or open new one\n        const clients = await self.clients.matchAll({\n            type: \"window\"\n        });\n        for (const client of clients){\n            if (client.url.includes(url) && \"focus\" in client) {\n                return client.focus();\n            }\n        }\n        // Open new window\n        if (self.clients.openWindow) {\n            return self.clients.openWindow(url);\n        }\n    } catch (error) {\n        console.error(\"Error opening notification URL:\", error);\n    }\n}\n/**\r\n * Get notification URL based on type and data\r\n */ function getNotificationUrl(notificationType) {\n    let data = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    if (data.actionUrl) {\n        return data.actionUrl;\n    }\n    const baseUrl = NOTIFICATION_URLS[notificationType] || \"/dashboard\";\n    // Add specific IDs if available\n    if (data.appointmentId && baseUrl.includes(\"appointments\")) {\n        return \"\".concat(baseUrl, \"/\").concat(data.appointmentId);\n    }\n    if (data.prescriptionId && baseUrl.includes(\"prescriptions\")) {\n        return \"\".concat(baseUrl, \"/\").concat(data.prescriptionId);\n    }\n    return baseUrl;\n}\n/**\r\n * Track notification events for analytics\r\n */ async function trackNotificationEvent(event, data) {\n    try {\n        console.log(\"Tracking notification event:\", {\n            event,\n            data\n        });\n        // Store event locally\n        const eventData = {\n            event,\n            notificationType: data.notificationType,\n            timestamp: Date.now(),\n            userId: data.userId,\n            appointmentId: data.appointmentId,\n            prescriptionId: data.prescriptionId,\n            action: data.action\n        };\n        // Store in IndexedDB or localStorage\n        await storeNotificationEvent(eventData);\n        // Try to send to backend (with background sync fallback)\n        try {\n            await sendEventToBackend(eventData);\n        } catch (error) {\n            console.log(\"Failed to send event to backend, will retry later:\", error);\n        // Could implement background sync here\n        }\n    } catch (error) {\n        console.error(\"Error tracking notification event:\", error);\n    }\n}\n/**\r\n * Store notification event locally\r\n */ async function storeNotificationEvent(eventData) {\n    try {\n        // For simplicity, using cache API to store events\n        // In production, you might want to use IndexedDB\n        const cache = await caches.open(CACHE_NAME);\n        const eventKey = \"event-\".concat(eventData.timestamp);\n        const response = new Response(JSON.stringify(eventData), {\n            headers: {\n                \"Content-Type\": \"application/json\"\n            }\n        });\n        await cache.put(eventKey, response);\n        console.log(\"Notification event stored locally\");\n    } catch (error) {\n        console.error(\"Error storing notification event:\", error);\n    }\n}\n/**\r\n * Send event to backend\r\n */ async function sendEventToBackend(eventData) {\n    try {\n        const response = await fetch(\"\".concat(API_BASE_URL, \"/api/notification-events\"), {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify(eventData)\n        });\n        if (!response.ok) {\n            throw new Error(\"HTTP \".concat(response.status, \": \").concat(response.statusText));\n        }\n        console.log(\"Event sent to backend successfully\");\n    } catch (error) {\n        console.error(\"Error sending event to backend:\", error);\n        throw error;\n    }\n}\n/**\r\n * Background sync for offline events (optional)\r\n */ self.addEventListener(\"sync\", (event)=>{\n    if (event.tag === \"notification-events-sync\") {\n        console.log(\"Background sync triggered for notification events\");\n        event.waitUntil(syncNotificationEvents());\n    }\n});\n/**\r\n * Sync stored notification events when online\r\n */ async function syncNotificationEvents() {\n    try {\n        const cache = await caches.open(CACHE_NAME);\n        const keys = await cache.keys();\n        for (const request of keys){\n            if (request.url.includes(\"event-\")) {\n                try {\n                    const response = await cache.match(request);\n                    const eventData = await response.json();\n                    await sendEventToBackend(eventData);\n                    await cache.delete(request);\n                    console.log(\"Synced notification event:\", eventData.event);\n                } catch (error) {\n                    console.error(\"Error syncing event:\", error);\n                }\n            }\n        }\n    } catch (error) {\n        console.error(\"Error during notification events sync:\", error);\n    }\n}\n/**\r\n * Clean up old notification events\r\n */ self.addEventListener(\"activate\", (event)=>{\n    event.waitUntil(cleanupOldEvents());\n});\nasync function cleanupOldEvents() {\n    try {\n        const cache = await caches.open(CACHE_NAME);\n        const keys = await cache.keys();\n        const oneWeekAgo = Date.now() - 7 * 24 * 60 * 60 * 1000;\n        for (const request of keys){\n            if (request.url.includes(\"event-\")) {\n                const timestamp = parseInt(request.url.split(\"event-\")[1]);\n                if (timestamp < oneWeekAgo) {\n                    await cache.delete(request);\n                }\n            }\n        }\n        console.log(\"Cleaned up old notification events\");\n    } catch (error) {\n        console.error(\"Error cleaning up old events:\", error);\n    }\n}\nconsole.log(\"MyTelmed Push Notification Service Worker loaded\");\n// Export functions for testing\nif ( true && module.exports) {\n    module.exports = {\n        showNotification,\n        handleNotificationClick,\n        getNotificationUrl,\n        trackNotificationEvent\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                /* unsupported import.meta.webpackHot */ undefined.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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dkIsUUFBUXVCLEtBQUssQ0FBQyxpQ0FBaUNBO0lBQ25EO0FBQ0o7QUFFQXZCLFFBQVFDLEdBQUcsQ0FBQztBQUVaLCtCQUErQjtBQUMvQixJQUFJLEtBQTZCLElBQUkyRixPQUFPQyxPQUFPLEVBQUU7SUFDakRELE9BQU9DLE9BQU8sR0FBRztRQUNicEU7UUFDQUs7UUFDQWU7UUFDQWQ7SUFDSjtBQUNKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3B1YmxpYy9zdy1wdXNoLmpzPzlmMDMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIE15VGVsbWVkIFB1c2ggTm90aWZpY2F0aW9uIFNlcnZpY2UgV29ya2VyXHJcbiAqIEhhbmRsZXMgcHVzaCBldmVudHMsIG5vdGlmaWNhdGlvbiBjbGlja3MsIGFuZCBiYWNrZ3JvdW5kIHN5bmNcclxuICovXHJcblxyXG4vLyBXb3JrYm94IG1hbmlmZXN0IGluamVjdGlvbiAtIHJlcXVpcmVkIGZvciBQV0EgY2FjaGluZ1xyXG5pbXBvcnRTY3JpcHRzKFwiaHR0cHM6Ly9zdG9yYWdlLmdvb2dsZWFwaXMuY29tL3dvcmtib3gtY2RuL3JlbGVhc2VzLzYuNC4xL3dvcmtib3gtc3cuanNcIik7XHJcblxyXG4vLyBJbmplY3QgdGhlIG1hbmlmZXN0IC0gdGhpcyB3aWxsIGJlIHJlcGxhY2VkIGJ5IFdvcmtib3ggZHVyaW5nIGJ1aWxkXHJcbmlmICh0eXBlb2Ygc2VsZi5fX1dCX01BTklGRVNUICE9PSBcInVuZGVmaW5lZFwiKSB7XHJcbiAgICAvLyBUaGlzIGVuc3VyZXMgdGhlIG1hbmlmZXN0IGlzIGluY2x1ZGVkIGluIHRoZSBzZXJ2aWNlIHdvcmtlclxyXG4gICAgY29uc29sZS5sb2coXCJXb3JrYm94IG1hbmlmZXN0IGxvYWRlZFwiKTtcclxufVxyXG5cclxuLy8gQ29uc3RhbnRzXHJcbmNvbnN0IE5PVElGSUNBVElPTl9UQUdfUFJFRklYID0gXCJteXRlbG1lZC1cIjtcclxuY29uc3QgQ0FDSEVfTkFNRSA9IFwibXl0ZWxtZWQtbm90aWZpY2F0aW9ucy12MVwiO1xyXG5jb25zdCBBUElfQkFTRV9VUkwgPSBzZWxmLmxvY2F0aW9uLm9yaWdpbjtcclxuY29uc3QgRkFMTEJBQ0tfSUNPTiA9IFwiL2Fzc2V0cy9sb2dvcy9teXRlbG1lZC1sb2dvLnBuZ1wiO1xyXG5jb25zdCBGQUxMQkFDS19CQURHRSA9IFwiL2Fzc2V0cy9sb2dvcy9teXRlbG1lZC1sb2dvLnBuZ1wiO1xyXG5cclxuLy8gVVJMIG1hcHBpbmdzIGZvciBkaWZmZXJlbnQgbm90aWZpY2F0aW9uIHR5cGVzXHJcbmNvbnN0IE5PVElGSUNBVElPTl9VUkxTID0ge1xyXG4gICAgQVBQT0lOVE1FTlRfUkVNSU5ERVJfUEFUSUVOVDogXCIvcGF0aWVudC9hcHBvaW50bWVudFwiLFxyXG4gICAgQVBQT0lOVE1FTlRfQ09ORklSTUFUSU9OX1BBVElFTlQ6IFwiL3BhdGllbnQvYXBwb2ludG1lbnRcIixcclxuICAgIEFQUE9JTlRNRU5UX0NBTkNFTF9QQVRJRU5UOiBcIi9wYXRpZW50L2FwcG9pbnRtZW50XCIsXHJcbiAgICBBUFBPSU5UTUVOVF9CT09LRURfUEFUSUVOVDogXCIvcGF0aWVudC9hcHBvaW50bWVudFwiLFxyXG4gICAgUFJFU0NSSVBUSU9OX0NSRUFURUQ6IFwiL3BhdGllbnQvcHJlc2NyaXB0aW9uXCIsXHJcbiAgICBQUkVTQ1JJUFRJT05fRVhQSVJJTkc6IFwiL3BhdGllbnQvcHJlc2NyaXB0aW9uXCIsXHJcbn07XHJcblxyXG4vKipcclxuICogUHVzaCBldmVudCBoYW5kbGVyIC0gcmVjZWl2ZXMgbm90aWZpY2F0aW9ucyBmcm9tIGJhY2tlbmRcclxuICovXHJcbnNlbGYuYWRkRXZlbnRMaXN0ZW5lcihcInB1c2hcIiwgKGV2ZW50KSA9PiB7XHJcbiAgICBjb25zb2xlLmxvZyhcIlB1c2ggbm90aWZpY2F0aW9uIHJlY2VpdmVkOlwiLCBldmVudCk7XHJcblxyXG4gICAgaWYgKCFldmVudC5kYXRhKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coXCJQdXNoIGV2ZW50IGhhcyBubyBkYXRhXCIpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB0cnkge1xyXG4gICAgICAgIC8vIFBhcnNlIG5vdGlmaWNhdGlvbiBwYXlsb2FkXHJcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IGV2ZW50LmRhdGEuanNvbigpO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFwiUHVzaCBwYXlsb2FkOlwiLCBwYXlsb2FkKTtcclxuXHJcbiAgICAgICAgLy8gVmFsaWRhdGUgcGF5bG9hZFxyXG4gICAgICAgIGlmICghcGF5bG9hZC50aXRsZSB8fCAhcGF5bG9hZC5ib2R5KSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJJbnZhbGlkIHB1c2ggcGF5bG9hZCAtIG1pc3NpbmcgdGl0bGUgb3IgYm9keVwiKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gU2hvdyBub3RpZmljYXRpb25cclxuICAgICAgICBldmVudC53YWl0VW50aWwoc2hvd05vdGlmaWNhdGlvbihwYXlsb2FkKSk7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBwcm9jZXNzaW5nIHB1c2ggZXZlbnQ6XCIsIGVycm9yKTtcclxuXHJcbiAgICAgICAgLy8gU2hvdyBmYWxsYmFjayBub3RpZmljYXRpb25cclxuICAgICAgICBldmVudC53YWl0VW50aWwoc2hvd0ZhbGxiYWNrTm90aWZpY2F0aW9uKFwiTXlUZWxtZWQgTm90aWZpY2F0aW9uXCIsIFwiWW91IGhhdmUgYSBuZXcgbm90aWZpY2F0aW9uXCIpKTtcclxuICAgIH1cclxufSk7XHJcblxyXG4vKipcclxuICogTm90aWZpY2F0aW9uIGNsaWNrIGhhbmRsZXJcclxuICovXHJcbnNlbGYuYWRkRXZlbnRMaXN0ZW5lcihcIm5vdGlmaWNhdGlvbmNsaWNrXCIsIChldmVudCkgPT4ge1xyXG4gICAgY29uc29sZS5sb2coXCJOb3RpZmljYXRpb24gY2xpY2tlZDpcIiwgZXZlbnQpO1xyXG5cclxuICAgIGNvbnN0IG5vdGlmaWNhdGlvbiA9IGV2ZW50Lm5vdGlmaWNhdGlvbjtcclxuICAgIGNvbnN0IGFjdGlvbiA9IGV2ZW50LmFjdGlvbjtcclxuICAgIGNvbnN0IGRhdGEgPSBub3RpZmljYXRpb24uZGF0YSB8fCB7fTtcclxuXHJcbiAgICAvLyBDbG9zZSB0aGUgbm90aWZpY2F0aW9uXHJcbiAgICBub3RpZmljYXRpb24uY2xvc2UoKTtcclxuXHJcbiAgICAvLyBIYW5kbGUgZGlmZmVyZW50IGFjdGlvbnNcclxuICAgIGV2ZW50LndhaXRVbnRpbChoYW5kbGVOb3RpZmljYXRpb25DbGljayhhY3Rpb24sIGRhdGEpKTtcclxufSk7XHJcblxyXG4vKipcclxuICogTm90aWZpY2F0aW9uIGNsb3NlIGhhbmRsZXJcclxuICovXHJcbnNlbGYuYWRkRXZlbnRMaXN0ZW5lcihcIm5vdGlmaWNhdGlvbmNsb3NlXCIsIChldmVudCkgPT4ge1xyXG4gICAgY29uc29sZS5sb2coXCJOb3RpZmljYXRpb24gY2xvc2VkOlwiLCBldmVudCk7XHJcblxyXG4gICAgY29uc3QgZGF0YSA9IGV2ZW50Lm5vdGlmaWNhdGlvbi5kYXRhIHx8IHt9O1xyXG5cclxuICAgIC8vIFRyYWNrIG5vdGlmaWNhdGlvbiBkaXNtaXNzYWxcclxuICAgIGV2ZW50LndhaXRVbnRpbCh0cmFja05vdGlmaWNhdGlvbkV2ZW50KFwiZGlzbWlzc2VkXCIsIGRhdGEpKTtcclxufSk7XHJcblxyXG4vKipcclxuICogU2hvdyBub3RpZmljYXRpb24gd2l0aCBwcm9wZXIgZm9ybWF0dGluZ1xyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gc2hvd05vdGlmaWNhdGlvbihwYXlsb2FkKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IHtcclxuICAgICAgICAgICAgdGl0bGUsXHJcbiAgICAgICAgICAgIGJvZHksXHJcbiAgICAgICAgICAgIGljb24gPSBGQUxMQkFDS19JQ09OLFxyXG4gICAgICAgICAgICBiYWRnZSA9IEZBTExCQUNLX0JBREdFLFxyXG4gICAgICAgICAgICBpbWFnZSxcclxuICAgICAgICAgICAgdGFnLFxyXG4gICAgICAgICAgICBkYXRhID0ge30sXHJcbiAgICAgICAgICAgIGFjdGlvbnMgPSBbXSxcclxuICAgICAgICAgICAgcmVxdWlyZUludGVyYWN0aW9uID0gZmFsc2UsXHJcbiAgICAgICAgICAgIHNpbGVudCA9IGZhbHNlLFxyXG4gICAgICAgICAgICB2aWJyYXRlID0gWzIwMCwgMTAwLCAyMDBdLFxyXG4gICAgICAgIH0gPSBwYXlsb2FkO1xyXG5cclxuICAgICAgICAvLyBDcmVhdGUgbm90aWZpY2F0aW9uIG9wdGlvbnNcclxuICAgICAgICBjb25zdCBvcHRpb25zID0ge1xyXG4gICAgICAgICAgICBib2R5LFxyXG4gICAgICAgICAgICBpY29uLFxyXG4gICAgICAgICAgICBiYWRnZSxcclxuICAgICAgICAgICAgaW1hZ2UsXHJcbiAgICAgICAgICAgIHRhZzogdGFnIHx8IGAke05PVElGSUNBVElPTl9UQUdfUFJFRklYfSR7RGF0ZS5ub3coKX1gLFxyXG4gICAgICAgICAgICBkYXRhOiB7XHJcbiAgICAgICAgICAgICAgICAuLi5kYXRhLFxyXG4gICAgICAgICAgICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpLFxyXG4gICAgICAgICAgICAgICAgdXJsOiBnZXROb3RpZmljYXRpb25VcmwoZGF0YS5ub3RpZmljYXRpb25UeXBlLCBkYXRhKSxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgYWN0aW9uczogYWN0aW9ucy5tYXAoKGFjdGlvbikgPT4gKHtcclxuICAgICAgICAgICAgICAgIGFjdGlvbjogYWN0aW9uLmFjdGlvbixcclxuICAgICAgICAgICAgICAgIHRpdGxlOiBhY3Rpb24udGl0bGUsXHJcbiAgICAgICAgICAgICAgICBpY29uOiBhY3Rpb24uaWNvbixcclxuICAgICAgICAgICAgfSkpLFxyXG4gICAgICAgICAgICByZXF1aXJlSW50ZXJhY3Rpb24sXHJcbiAgICAgICAgICAgIHNpbGVudCxcclxuICAgICAgICAgICAgdmlicmF0ZTogc2lsZW50ID8gW10gOiB2aWJyYXRlLFxyXG4gICAgICAgICAgICByZW5vdGlmeTogdHJ1ZSxcclxuICAgICAgICAgICAgcGVyc2lzdGVudDogdHJ1ZSxcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBjb25zb2xlLmxvZyhcIlNob3dpbmcgbm90aWZpY2F0aW9uIHdpdGggb3B0aW9uczpcIiwgb3B0aW9ucyk7XHJcblxyXG4gICAgICAgIC8vIFNob3cgdGhlIG5vdGlmaWNhdGlvblxyXG4gICAgICAgIGF3YWl0IHNlbGYucmVnaXN0cmF0aW9uLnNob3dOb3RpZmljYXRpb24odGl0bGUsIG9wdGlvbnMpO1xyXG5cclxuICAgICAgICAvLyBUcmFjayBub3RpZmljYXRpb24gZGVsaXZlcnlcclxuICAgICAgICBhd2FpdCB0cmFja05vdGlmaWNhdGlvbkV2ZW50KFwiZGVsaXZlcmVkXCIsIGRhdGEpO1xyXG5cclxuICAgICAgICBjb25zb2xlLmxvZyhcIk5vdGlmaWNhdGlvbiBzaG93biBzdWNjZXNzZnVsbHlcIik7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBzaG93aW5nIG5vdGlmaWNhdGlvbjpcIiwgZXJyb3IpO1xyXG4gICAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICogU2hvdyBmYWxsYmFjayBub3RpZmljYXRpb24gd2hlbiBwYXlsb2FkIGlzIGludmFsaWRcclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIHNob3dGYWxsYmFja05vdGlmaWNhdGlvbih0aXRsZSwgYm9keSkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBjb25zdCBvcHRpb25zID0ge1xyXG4gICAgICAgICAgICBib2R5LFxyXG4gICAgICAgICAgICBpY29uOiBGQUxMQkFDS19JQ09OLFxyXG4gICAgICAgICAgICBiYWRnZTogRkFMTEJBQ0tfQkFER0UsXHJcbiAgICAgICAgICAgIHRhZzogYCR7Tk9USUZJQ0FUSU9OX1RBR19QUkVGSVh9ZmFsbGJhY2tgLFxyXG4gICAgICAgICAgICBkYXRhOiB7XHJcbiAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IERhdGUubm93KCksXHJcbiAgICAgICAgICAgICAgICB0eXBlOiBcImZhbGxiYWNrXCIsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHJlcXVpcmVJbnRlcmFjdGlvbjogZmFsc2UsXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgYXdhaXQgc2VsZi5yZWdpc3RyYXRpb24uc2hvd05vdGlmaWNhdGlvbih0aXRsZSwgb3B0aW9ucyk7XHJcbiAgICAgICAgY29uc29sZS5sb2coXCJGYWxsYmFjayBub3RpZmljYXRpb24gc2hvd25cIik7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBzaG93aW5nIGZhbGxiYWNrIG5vdGlmaWNhdGlvbjpcIiwgZXJyb3IpO1xyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICogSGFuZGxlIG5vdGlmaWNhdGlvbiBjbGljayBldmVudHNcclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIGhhbmRsZU5vdGlmaWNhdGlvbkNsaWNrKGFjdGlvbiwgZGF0YSkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBjb25zb2xlLmxvZyhcIkhhbmRsaW5nIG5vdGlmaWNhdGlvbiBjbGljazpcIiwgeyBhY3Rpb24sIGRhdGEgfSk7XHJcblxyXG4gICAgICAgIC8vIFRyYWNrIGNsaWNrIGV2ZW50XHJcbiAgICAgICAgYXdhaXQgdHJhY2tOb3RpZmljYXRpb25FdmVudChcImNsaWNrZWRcIiwgeyAuLi5kYXRhLCBhY3Rpb24gfSk7XHJcblxyXG4gICAgICAgIC8vIEhhbmRsZSBzcGVjaWZpYyBhY3Rpb25zXHJcbiAgICAgICAgYXdhaXQgb3Blbk5vdGlmaWNhdGlvblVybChkYXRhKTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGhhbmRsaW5nIG5vdGlmaWNhdGlvbiBjbGljazpcIiwgZXJyb3IpO1xyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICogT3BlbiBub3RpZmljYXRpb24gVVJMIGluIGNsaWVudFxyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gb3Blbk5vdGlmaWNhdGlvblVybChkYXRhKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IHVybCA9IGRhdGEudXJsIHx8IGdldE5vdGlmaWNhdGlvblVybChkYXRhLm5vdGlmaWNhdGlvblR5cGUsIGRhdGEpO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFwiT3BlbmluZyBub3RpZmljYXRpb24gVVJMOlwiLCB1cmwpO1xyXG5cclxuICAgICAgICAvLyBGb2N1cyBleGlzdGluZyB3aW5kb3cgb3Igb3BlbiBuZXcgb25lXHJcbiAgICAgICAgY29uc3QgY2xpZW50cyA9IGF3YWl0IHNlbGYuY2xpZW50cy5tYXRjaEFsbCh7IHR5cGU6IFwid2luZG93XCIgfSk7XHJcblxyXG4gICAgICAgIGZvciAoY29uc3QgY2xpZW50IG9mIGNsaWVudHMpIHtcclxuICAgICAgICAgICAgaWYgKGNsaWVudC51cmwuaW5jbHVkZXModXJsKSAmJiBcImZvY3VzXCIgaW4gY2xpZW50KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY2xpZW50LmZvY3VzKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIE9wZW4gbmV3IHdpbmRvd1xyXG4gICAgICAgIGlmIChzZWxmLmNsaWVudHMub3BlbldpbmRvdykge1xyXG4gICAgICAgICAgICByZXR1cm4gc2VsZi5jbGllbnRzLm9wZW5XaW5kb3codXJsKTtcclxuICAgICAgICB9XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBvcGVuaW5nIG5vdGlmaWNhdGlvbiBVUkw6XCIsIGVycm9yKTtcclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEdldCBub3RpZmljYXRpb24gVVJMIGJhc2VkIG9uIHR5cGUgYW5kIGRhdGFcclxuICovXHJcbmZ1bmN0aW9uIGdldE5vdGlmaWNhdGlvblVybChub3RpZmljYXRpb25UeXBlLCBkYXRhID0ge30pIHtcclxuICAgIGlmIChkYXRhLmFjdGlvblVybCkge1xyXG4gICAgICAgIHJldHVybiBkYXRhLmFjdGlvblVybDtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBiYXNlVXJsID0gTk9USUZJQ0FUSU9OX1VSTFNbbm90aWZpY2F0aW9uVHlwZV0gfHwgXCIvZGFzaGJvYXJkXCI7XHJcblxyXG4gICAgLy8gQWRkIHNwZWNpZmljIElEcyBpZiBhdmFpbGFibGVcclxuICAgIGlmIChkYXRhLmFwcG9pbnRtZW50SWQgJiYgYmFzZVVybC5pbmNsdWRlcyhcImFwcG9pbnRtZW50c1wiKSkge1xyXG4gICAgICAgIHJldHVybiBgJHtiYXNlVXJsfS8ke2RhdGEuYXBwb2ludG1lbnRJZH1gO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChkYXRhLnByZXNjcmlwdGlvbklkICYmIGJhc2VVcmwuaW5jbHVkZXMoXCJwcmVzY3JpcHRpb25zXCIpKSB7XHJcbiAgICAgICAgcmV0dXJuIGAke2Jhc2VVcmx9LyR7ZGF0YS5wcmVzY3JpcHRpb25JZH1gO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBiYXNlVXJsO1xyXG59XHJcblxyXG4vKipcclxuICogVHJhY2sgbm90aWZpY2F0aW9uIGV2ZW50cyBmb3IgYW5hbHl0aWNzXHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiB0cmFja05vdGlmaWNhdGlvbkV2ZW50KGV2ZW50LCBkYXRhKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFwiVHJhY2tpbmcgbm90aWZpY2F0aW9uIGV2ZW50OlwiLCB7IGV2ZW50LCBkYXRhIH0pO1xyXG5cclxuICAgICAgICAvLyBTdG9yZSBldmVudCBsb2NhbGx5XHJcbiAgICAgICAgY29uc3QgZXZlbnREYXRhID0ge1xyXG4gICAgICAgICAgICBldmVudCxcclxuICAgICAgICAgICAgbm90aWZpY2F0aW9uVHlwZTogZGF0YS5ub3RpZmljYXRpb25UeXBlLFxyXG4gICAgICAgICAgICB0aW1lc3RhbXA6IERhdGUubm93KCksXHJcbiAgICAgICAgICAgIHVzZXJJZDogZGF0YS51c2VySWQsXHJcbiAgICAgICAgICAgIGFwcG9pbnRtZW50SWQ6IGRhdGEuYXBwb2ludG1lbnRJZCxcclxuICAgICAgICAgICAgcHJlc2NyaXB0aW9uSWQ6IGRhdGEucHJlc2NyaXB0aW9uSWQsXHJcbiAgICAgICAgICAgIGFjdGlvbjogZGF0YS5hY3Rpb24sXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLy8gU3RvcmUgaW4gSW5kZXhlZERCIG9yIGxvY2FsU3RvcmFnZVxyXG4gICAgICAgIGF3YWl0IHN0b3JlTm90aWZpY2F0aW9uRXZlbnQoZXZlbnREYXRhKTtcclxuXHJcbiAgICAgICAgLy8gVHJ5IHRvIHNlbmQgdG8gYmFja2VuZCAod2l0aCBiYWNrZ3JvdW5kIHN5bmMgZmFsbGJhY2spXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgYXdhaXQgc2VuZEV2ZW50VG9CYWNrZW5kKGV2ZW50RGF0YSk7XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJGYWlsZWQgdG8gc2VuZCBldmVudCB0byBiYWNrZW5kLCB3aWxsIHJldHJ5IGxhdGVyOlwiLCBlcnJvcik7XHJcbiAgICAgICAgICAgIC8vIENvdWxkIGltcGxlbWVudCBiYWNrZ3JvdW5kIHN5bmMgaGVyZVxyXG4gICAgICAgIH1cclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIHRyYWNraW5nIG5vdGlmaWNhdGlvbiBldmVudDpcIiwgZXJyb3IpO1xyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICogU3RvcmUgbm90aWZpY2F0aW9uIGV2ZW50IGxvY2FsbHlcclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIHN0b3JlTm90aWZpY2F0aW9uRXZlbnQoZXZlbnREYXRhKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIC8vIEZvciBzaW1wbGljaXR5LCB1c2luZyBjYWNoZSBBUEkgdG8gc3RvcmUgZXZlbnRzXHJcbiAgICAgICAgLy8gSW4gcHJvZHVjdGlvbiwgeW91IG1pZ2h0IHdhbnQgdG8gdXNlIEluZGV4ZWREQlxyXG4gICAgICAgIGNvbnN0IGNhY2hlID0gYXdhaXQgY2FjaGVzLm9wZW4oQ0FDSEVfTkFNRSk7XHJcbiAgICAgICAgY29uc3QgZXZlbnRLZXkgPSBgZXZlbnQtJHtldmVudERhdGEudGltZXN0YW1wfWA7XHJcblxyXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gbmV3IFJlc3BvbnNlKEpTT04uc3RyaW5naWZ5KGV2ZW50RGF0YSksIHtcclxuICAgICAgICAgICAgaGVhZGVyczogeyBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9LFxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBhd2FpdCBjYWNoZS5wdXQoZXZlbnRLZXksIHJlc3BvbnNlKTtcclxuICAgICAgICBjb25zb2xlLmxvZyhcIk5vdGlmaWNhdGlvbiBldmVudCBzdG9yZWQgbG9jYWxseVwiKTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIHN0b3Jpbmcgbm90aWZpY2F0aW9uIGV2ZW50OlwiLCBlcnJvcik7XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBTZW5kIGV2ZW50IHRvIGJhY2tlbmRcclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIHNlbmRFdmVudFRvQmFja2VuZChldmVudERhdGEpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtBUElfQkFTRV9VUkx9L2FwaS9ub3RpZmljYXRpb24tZXZlbnRzYCwge1xyXG4gICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxyXG4gICAgICAgICAgICBoZWFkZXJzOiB7XHJcbiAgICAgICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoZXZlbnREYXRhKSxcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEhUVFAgJHtyZXNwb25zZS5zdGF0dXN9OiAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zb2xlLmxvZyhcIkV2ZW50IHNlbnQgdG8gYmFja2VuZCBzdWNjZXNzZnVsbHlcIik7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBzZW5kaW5nIGV2ZW50IHRvIGJhY2tlbmQ6XCIsIGVycm9yKTtcclxuICAgICAgICB0aHJvdyBlcnJvcjtcclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEJhY2tncm91bmQgc3luYyBmb3Igb2ZmbGluZSBldmVudHMgKG9wdGlvbmFsKVxyXG4gKi9cclxuc2VsZi5hZGRFdmVudExpc3RlbmVyKFwic3luY1wiLCAoZXZlbnQpID0+IHtcclxuICAgIGlmIChldmVudC50YWcgPT09IFwibm90aWZpY2F0aW9uLWV2ZW50cy1zeW5jXCIpIHtcclxuICAgICAgICBjb25zb2xlLmxvZyhcIkJhY2tncm91bmQgc3luYyB0cmlnZ2VyZWQgZm9yIG5vdGlmaWNhdGlvbiBldmVudHNcIik7XHJcbiAgICAgICAgZXZlbnQud2FpdFVudGlsKHN5bmNOb3RpZmljYXRpb25FdmVudHMoKSk7XHJcbiAgICB9XHJcbn0pO1xyXG5cclxuLyoqXHJcbiAqIFN5bmMgc3RvcmVkIG5vdGlmaWNhdGlvbiBldmVudHMgd2hlbiBvbmxpbmVcclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIHN5bmNOb3RpZmljYXRpb25FdmVudHMoKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IGNhY2hlID0gYXdhaXQgY2FjaGVzLm9wZW4oQ0FDSEVfTkFNRSk7XHJcbiAgICAgICAgY29uc3Qga2V5cyA9IGF3YWl0IGNhY2hlLmtleXMoKTtcclxuXHJcbiAgICAgICAgZm9yIChjb25zdCByZXF1ZXN0IG9mIGtleXMpIHtcclxuICAgICAgICAgICAgaWYgKHJlcXVlc3QudXJsLmluY2x1ZGVzKFwiZXZlbnQtXCIpKSB7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY2FjaGUubWF0Y2gocmVxdWVzdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXZlbnREYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBhd2FpdCBzZW5kRXZlbnRUb0JhY2tlbmQoZXZlbnREYXRhKTtcclxuICAgICAgICAgICAgICAgICAgICBhd2FpdCBjYWNoZS5kZWxldGUocmVxdWVzdCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiU3luY2VkIG5vdGlmaWNhdGlvbiBldmVudDpcIiwgZXZlbnREYXRhLmV2ZW50KTtcclxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIHN5bmNpbmcgZXZlbnQ6XCIsIGVycm9yKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGR1cmluZyBub3RpZmljYXRpb24gZXZlbnRzIHN5bmM6XCIsIGVycm9yKTtcclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIENsZWFuIHVwIG9sZCBub3RpZmljYXRpb24gZXZlbnRzXHJcbiAqL1xyXG5zZWxmLmFkZEV2ZW50TGlzdGVuZXIoXCJhY3RpdmF0ZVwiLCAoZXZlbnQpID0+IHtcclxuICAgIGV2ZW50LndhaXRVbnRpbChjbGVhbnVwT2xkRXZlbnRzKCkpO1xyXG59KTtcclxuXHJcbmFzeW5jIGZ1bmN0aW9uIGNsZWFudXBPbGRFdmVudHMoKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IGNhY2hlID0gYXdhaXQgY2FjaGVzLm9wZW4oQ0FDSEVfTkFNRSk7XHJcbiAgICAgICAgY29uc3Qga2V5cyA9IGF3YWl0IGNhY2hlLmtleXMoKTtcclxuICAgICAgICBjb25zdCBvbmVXZWVrQWdvID0gRGF0ZS5ub3coKSAtIDcgKiAyNCAqIDYwICogNjAgKiAxMDAwO1xyXG5cclxuICAgICAgICBmb3IgKGNvbnN0IHJlcXVlc3Qgb2Yga2V5cykge1xyXG4gICAgICAgICAgICBpZiAocmVxdWVzdC51cmwuaW5jbHVkZXMoXCJldmVudC1cIikpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHRpbWVzdGFtcCA9IHBhcnNlSW50KHJlcXVlc3QudXJsLnNwbGl0KFwiZXZlbnQtXCIpWzFdKTtcclxuICAgICAgICAgICAgICAgIGlmICh0aW1lc3RhbXAgPCBvbmVXZWVrQWdvKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgY2FjaGUuZGVsZXRlKHJlcXVlc3QpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zb2xlLmxvZyhcIkNsZWFuZWQgdXAgb2xkIG5vdGlmaWNhdGlvbiBldmVudHNcIik7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBjbGVhbmluZyB1cCBvbGQgZXZlbnRzOlwiLCBlcnJvcik7XHJcbiAgICB9XHJcbn1cclxuXHJcbmNvbnNvbGUubG9nKFwiTXlUZWxtZWQgUHVzaCBOb3RpZmljYXRpb24gU2VydmljZSBXb3JrZXIgbG9hZGVkXCIpO1xyXG5cclxuLy8gRXhwb3J0IGZ1bmN0aW9ucyBmb3IgdGVzdGluZ1xyXG5pZiAodHlwZW9mIG1vZHVsZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBtb2R1bGUuZXhwb3J0cykge1xyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgICAgICAgc2hvd05vdGlmaWNhdGlvbixcclxuICAgICAgICBoYW5kbGVOb3RpZmljYXRpb25DbGljayxcclxuICAgICAgICBnZXROb3RpZmljYXRpb25VcmwsXHJcbiAgICAgICAgdHJhY2tOb3RpZmljYXRpb25FdmVudCxcclxuICAgIH07XHJcbn1cclxuIl0sIm5hbWVzIjpbImltcG9ydFNjcmlwdHMiLCJzZWxmIiwiX19XQl9NQU5JRkVTVCIsImNvbnNvbGUiLCJsb2ciLCJOT1RJRklDQVRJT05fVEFHX1BSRUZJWCIsIkNBQ0hFX05BTUUiLCJBUElfQkFTRV9VUkwiLCJsb2NhdGlvbiIsIm9yaWdpbiIsIkZBTExCQUNLX0lDT04iLCJGQUxMQkFDS19CQURHRSIsIk5PVElGSUNBVElPTl9VUkxTIiwiQVBQT0lOVE1FTlRfUkVNSU5ERVJfUEFUSUVOVCIsIkFQUE9JTlRNRU5UX0NPTkZJUk1BVElPTl9QQVRJRU5UIiwiQVBQT0lOVE1FTlRfQ0FOQ0VMX1BBVElFTlQiLCJBUFBPSU5UTUVOVF9CT09LRURfUEFUSUVOVCIsIlBSRVNDUklQVElPTl9DUkVBVEVEIiwiUFJFU0NSSVBUSU9OX0VYUElSSU5HIiwiYWRkRXZlbnRMaXN0ZW5lciIsImV2ZW50IiwiZGF0YSIsInBheWxvYWQiLCJqc29uIiwidGl0bGUiLCJib2R5IiwiZXJyb3IiLCJ3YWl0VW50aWwiLCJzaG93Tm90aWZpY2F0aW9uIiwic2hvd0ZhbGxiYWNrTm90aWZpY2F0aW9uIiwibm90aWZpY2F0aW9uIiwiYWN0aW9uIiwiY2xvc2UiLCJoYW5kbGVOb3RpZmljYXRpb25DbGljayIsInRyYWNrTm90aWZpY2F0aW9uRXZlbnQiLCJpY29uIiwiYmFkZ2UiLCJpbWFnZSIsInRhZyIsImFjdGlvbnMiLCJyZXF1aXJlSW50ZXJhY3Rpb24iLCJzaWxlbnQiLCJ2aWJyYXRlIiwib3B0aW9ucyIsIkRhdGUiLCJub3ciLCJ0aW1lc3RhbXAiLCJ1cmwiLCJnZXROb3RpZmljYXRpb25VcmwiLCJub3RpZmljYXRpb25UeXBlIiwibWFwIiwicmVub3RpZnkiLCJwZXJzaXN0ZW50IiwicmVnaXN0cmF0aW9uIiwidHlwZSIsIm9wZW5Ob3RpZmljYXRpb25VcmwiLCJjbGllbnRzIiwibWF0Y2hBbGwiLCJjbGllbnQiLCJpbmNsdWRlcyIsImZvY3VzIiwib3BlbldpbmRvdyIsImFjdGlvblVybCIsImJhc2VVcmwiLCJhcHBvaW50bWVudElkIiwicHJlc2NyaXB0aW9uSWQiLCJldmVudERhdGEiLCJ1c2VySWQiLCJzdG9yZU5vdGlmaWNhdGlvbkV2ZW50Iiwic2VuZEV2ZW50VG9CYWNrZW5kIiwiY2FjaGUiLCJjYWNoZXMiLCJvcGVuIiwiZXZlbnRLZXkiLCJyZXNwb25zZSIsIlJlc3BvbnNlIiwiSlNPTiIsInN0cmluZ2lmeSIsImhlYWRlcnMiLCJwdXQiLCJmZXRjaCIsIm1ldGhvZCIsIm9rIiwiRXJyb3IiLCJzdGF0dXMiLCJzdGF0dXNUZXh0Iiwic3luY05vdGlmaWNhdGlvbkV2ZW50cyIsImtleXMiLCJyZXF1ZXN0IiwibWF0Y2giLCJkZWxldGUiLCJjbGVhbnVwT2xkRXZlbnRzIiwib25lV2Vla0FnbyIsInBhcnNlSW50Iiwic3BsaXQiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./public/sw-push.js\n"));

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			if (cachedModule.error !== undefined) throw cachedModule.error;
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		var threw = true;
/******/ 		try {
/******/ 			__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 			threw = false;
/******/ 		} finally {
/******/ 			if(threw) delete __webpack_module_cache__[moduleId];
/******/ 		}
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/trusted types policy */
/******/ 	!function() {
/******/ 		var policy;
/******/ 		__webpack_require__.tt = function() {
/******/ 			// Create Trusted Type policy if Trusted Types are available and the policy doesn't exist yet.
/******/ 			if (policy === undefined) {
/******/ 				policy = {
/******/ 					createScript: function(script) { return script; }
/******/ 				};
/******/ 				if (typeof trustedTypes !== "undefined" && trustedTypes.createPolicy) {
/******/ 					policy = trustedTypes.createPolicy("nextjs#bundler", policy);
/******/ 				}
/******/ 			}
/******/ 			return policy;
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/trusted types script */
/******/ 	!function() {
/******/ 		__webpack_require__.ts = function(script) { return __webpack_require__.tt().createScript(script); };
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/react refresh */
/******/ 	!function() {
/******/ 		if (__webpack_require__.i) {
/******/ 		__webpack_require__.i.push(function(options) {
/******/ 			var originalFactory = options.factory;
/******/ 			options.factory = function(moduleObject, moduleExports, webpackRequire) {
/******/ 				var hasRefresh = typeof self !== "undefined" && !!self.$RefreshInterceptModuleExecution$;
/******/ 				var cleanup = hasRefresh ? self.$RefreshInterceptModuleExecution$(moduleObject.id) : function() {};
/******/ 				try {
/******/ 					originalFactory.call(this, moduleObject, moduleExports, webpackRequire);
/******/ 				} finally {
/******/ 					cleanup();
/******/ 				}
/******/ 			}
/******/ 		})
/******/ 		}
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/compat */
/******/ 	
/******/ 	
/******/ 	// noop fns to prevent runtime errors during initialization
/******/ 	if (typeof self !== "undefined") {
/******/ 		self.$RefreshReg$ = function () {};
/******/ 		self.$RefreshSig$ = function () {
/******/ 			return function (type) {
/******/ 				return type;
/******/ 			};
/******/ 		};
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./public/sw-push.js");
/******/ 	
/******/ })()
;