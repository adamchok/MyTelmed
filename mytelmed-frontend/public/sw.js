/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (function() { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./public/sw-push.js":
/*!***************************!*\
  !*** ./public/sw-push.js ***!
  \***************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("/**\r\n * MyTelmed Push Notification Service Worker\r\n * Handles push events, notification clicks, and background sync\r\n */ // Workbox manifest injection - required for PWA caching\n\nimportScripts(\"https://storage.googleapis.com/workbox-cdn/releases/6.4.1/workbox-sw.js\");\n// Inject the manifest - this will be replaced by Workbox during build\nif (typeof [] !== \"undefined\") {\n    // This ensures the manifest is included in the service worker\n    console.log(\"Workbox manifest loaded\");\n}\n// Constants\nconst NOTIFICATION_TAG_PREFIX = \"mytelmed-\";\nconst CACHE_NAME = \"mytelmed-notifications-v1\";\nconst API_BASE_URL = self.location.origin;\nconst FALLBACK_ICON = \"/assets/logos/mytelmed-logo.png\";\nconst FALLBACK_BADGE = \"/assets/logos/mytelmed-logo.png\";\n// Notification action handlers\nconst NOTIFICATION_ACTIONS = {\n    view: \"View Details\",\n    dismiss: \"Dismiss\",\n    calendar: \"Add to Calendar\",\n    order: \"Order Now\",\n    renew: \"Renew Now\",\n    remind: \"Remind Later\",\n    track: \"Track Delivery\",\n    contact: \"Contact Support\"\n};\n// URL mappings for different notification types\nconst NOTIFICATION_URLS = {\n    APPOINTMENT_REMINDER_PATIENT: \"/appointments\",\n    APPOINTMENT_CONFIRMATION_PATIENT: \"/appointments\",\n    APPOINTMENT_CANCEL_PATIENT: \"/appointments\",\n    APPOINTMENT_BOOKED_PATIENT: \"/appointments\",\n    PRESCRIPTION_CREATED: \"/prescriptions\",\n    PRESCRIPTION_EXPIRING: \"/prescriptions\",\n    PRESCRIPTION_OUT_FOR_DELIVERY: \"/prescriptions/delivery\"\n};\n/**\r\n * Push event handler - receives notifications from backend\r\n */ self.addEventListener(\"push\", (event)=>{\n    console.log(\"Push notification received:\", event);\n    if (!event.data) {\n        console.log(\"Push event has no data\");\n        return;\n    }\n    try {\n        // Parse notification payload\n        const payload = event.data.json();\n        console.log(\"Push payload:\", payload);\n        // Validate payload\n        if (!payload.title || !payload.body) {\n            console.error(\"Invalid push payload - missing title or body\");\n            return;\n        }\n        // Show notification\n        event.waitUntil(showNotification(payload));\n    } catch (error) {\n        console.error(\"Error processing push event:\", error);\n        // Show fallback notification\n        event.waitUntil(showFallbackNotification(\"MyTelmed Notification\", \"You have a new notification\"));\n    }\n});\n/**\r\n * Notification click handler\r\n */ self.addEventListener(\"notificationclick\", (event)=>{\n    console.log(\"Notification clicked:\", event);\n    const notification = event.notification;\n    const action = event.action;\n    const data = notification.data || {};\n    // Close the notification\n    notification.close();\n    // Handle different actions\n    event.waitUntil(handleNotificationClick(action, data));\n});\n/**\r\n * Notification close handler\r\n */ self.addEventListener(\"notificationclose\", (event)=>{\n    console.log(\"Notification closed:\", event);\n    const data = event.notification.data || {};\n    // Track notification dismissal\n    event.waitUntil(trackNotificationEvent(\"dismissed\", data));\n});\n/**\r\n * Show notification with proper formatting\r\n */ async function showNotification(payload) {\n    try {\n        const { title, body, icon = FALLBACK_ICON, badge = FALLBACK_BADGE, image, tag, data = {}, actions = [], requireInteraction = false, silent = false, vibrate = [\n            200,\n            100,\n            200\n        ] } = payload;\n        // Create notification options\n        const options = {\n            body,\n            icon,\n            badge,\n            image,\n            tag: tag || \"\".concat(NOTIFICATION_TAG_PREFIX).concat(Date.now()),\n            data: {\n                ...data,\n                timestamp: Date.now(),\n                url: getNotificationUrl(data.notificationType, data)\n            },\n            actions: actions.map((action)=>({\n                    action: action.action,\n                    title: NOTIFICATION_ACTIONS[action.action] || action.title,\n                    icon: action.icon\n                })),\n            requireInteraction,\n            silent,\n            vibrate: silent ? [] : vibrate,\n            renotify: true,\n            persistent: true\n        };\n        console.log(\"Showing notification with options:\", options);\n        // Show the notification\n        await self.registration.showNotification(title, options);\n        // Track notification delivery\n        await trackNotificationEvent(\"delivered\", data);\n        console.log(\"Notification shown successfully\");\n    } catch (error) {\n        console.error(\"Error showing notification:\", error);\n        throw error;\n    }\n}\n/**\r\n * Show fallback notification when payload is invalid\r\n */ async function showFallbackNotification(title, body) {\n    try {\n        const options = {\n            body,\n            icon: FALLBACK_ICON,\n            badge: FALLBACK_BADGE,\n            tag: \"\".concat(NOTIFICATION_TAG_PREFIX, \"fallback\"),\n            data: {\n                timestamp: Date.now(),\n                type: \"fallback\"\n            },\n            requireInteraction: false\n        };\n        await self.registration.showNotification(title, options);\n        console.log(\"Fallback notification shown\");\n    } catch (error) {\n        console.error(\"Error showing fallback notification:\", error);\n    }\n}\n/**\r\n * Handle notification click events\r\n */ async function handleNotificationClick(action, data) {\n    try {\n        console.log(\"Handling notification click:\", {\n            action,\n            data\n        });\n        // Track click event\n        await trackNotificationEvent(\"clicked\", {\n            ...data,\n            action\n        });\n        // Handle specific actions\n        await openNotificationUrl(data);\n    } catch (error) {\n        console.error(\"Error handling notification click:\", error);\n    }\n}\n/**\r\n * Open notification URL in client\r\n */ async function openNotificationUrl(data) {\n    try {\n        const url = data.url || getNotificationUrl(data.notificationType, data);\n        console.log(\"Opening notification URL:\", url);\n        // Focus existing window or open new one\n        const clients = await self.clients.matchAll({\n            type: \"window\"\n        });\n        for (const client of clients){\n            if (client.url.includes(url) && \"focus\" in client) {\n                return client.focus();\n            }\n        }\n        // Open new window\n        if (self.clients.openWindow) {\n            return self.clients.openWindow(url);\n        }\n    } catch (error) {\n        console.error(\"Error opening notification URL:\", error);\n    }\n}\n/**\r\n * Get notification URL based on type and data\r\n */ function getNotificationUrl(notificationType) {\n    let data = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    if (data.actionUrl) {\n        return data.actionUrl;\n    }\n    const baseUrl = NOTIFICATION_URLS[notificationType] || \"/dashboard\";\n    // Add specific IDs if available\n    if (data.appointmentId && baseUrl.includes(\"appointments\")) {\n        return \"\".concat(baseUrl, \"/\").concat(data.appointmentId);\n    }\n    if (data.prescriptionId && baseUrl.includes(\"prescriptions\")) {\n        return \"\".concat(baseUrl, \"/\").concat(data.prescriptionId);\n    }\n    return baseUrl;\n}\n/**\r\n * Track notification events for analytics\r\n */ async function trackNotificationEvent(event, data) {\n    try {\n        console.log(\"Tracking notification event:\", {\n            event,\n            data\n        });\n        // Store event locally\n        const eventData = {\n            event,\n            notificationType: data.notificationType,\n            timestamp: Date.now(),\n            userId: data.userId,\n            appointmentId: data.appointmentId,\n            prescriptionId: data.prescriptionId,\n            action: data.action\n        };\n        // Store in IndexedDB or localStorage\n        await storeNotificationEvent(eventData);\n        // Try to send to backend (with background sync fallback)\n        try {\n            await sendEventToBackend(eventData);\n        } catch (error) {\n            console.log(\"Failed to send event to backend, will retry later:\", error);\n        // Could implement background sync here\n        }\n    } catch (error) {\n        console.error(\"Error tracking notification event:\", error);\n    }\n}\n/**\r\n * Store notification event locally\r\n */ async function storeNotificationEvent(eventData) {\n    try {\n        // For simplicity, using cache API to store events\n        // In production, you might want to use IndexedDB\n        const cache = await caches.open(CACHE_NAME);\n        const eventKey = \"event-\".concat(eventData.timestamp);\n        const response = new Response(JSON.stringify(eventData), {\n            headers: {\n                \"Content-Type\": \"application/json\"\n            }\n        });\n        await cache.put(eventKey, response);\n        console.log(\"Notification event stored locally\");\n    } catch (error) {\n        console.error(\"Error storing notification event:\", error);\n    }\n}\n/**\r\n * Send event to backend\r\n */ async function sendEventToBackend(eventData) {\n    try {\n        const response = await fetch(\"\".concat(API_BASE_URL, \"/api/notification-events\"), {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify(eventData)\n        });\n        if (!response.ok) {\n            throw new Error(\"HTTP \".concat(response.status, \": \").concat(response.statusText));\n        }\n        console.log(\"Event sent to backend successfully\");\n    } catch (error) {\n        console.error(\"Error sending event to backend:\", error);\n        throw error;\n    }\n}\n/**\r\n * Background sync for offline events (optional)\r\n */ self.addEventListener(\"sync\", (event)=>{\n    if (event.tag === \"notification-events-sync\") {\n        console.log(\"Background sync triggered for notification events\");\n        event.waitUntil(syncNotificationEvents());\n    }\n});\n/**\r\n * Sync stored notification events when online\r\n */ async function syncNotificationEvents() {\n    try {\n        const cache = await caches.open(CACHE_NAME);\n        const keys = await cache.keys();\n        for (const request of keys){\n            if (request.url.includes(\"event-\")) {\n                try {\n                    const response = await cache.match(request);\n                    const eventData = await response.json();\n                    await sendEventToBackend(eventData);\n                    await cache.delete(request);\n                    console.log(\"Synced notification event:\", eventData.event);\n                } catch (error) {\n                    console.error(\"Error syncing event:\", error);\n                }\n            }\n        }\n    } catch (error) {\n        console.error(\"Error during notification events sync:\", error);\n    }\n}\n/**\r\n * Clean up old notification events\r\n */ self.addEventListener(\"activate\", (event)=>{\n    event.waitUntil(cleanupOldEvents());\n});\nasync function cleanupOldEvents() {\n    try {\n        const cache = await caches.open(CACHE_NAME);\n        const keys = await cache.keys();\n        const oneWeekAgo = Date.now() - 7 * 24 * 60 * 60 * 1000;\n        for (const request of keys){\n            if (request.url.includes(\"event-\")) {\n                const timestamp = parseInt(request.url.split(\"event-\")[1]);\n                if (timestamp < oneWeekAgo) {\n                    await cache.delete(request);\n                }\n            }\n        }\n        console.log(\"Cleaned up old notification events\");\n    } catch (error) {\n        console.error(\"Error cleaning up old events:\", error);\n    }\n}\nconsole.log(\"MyTelmed Push Notification Service Worker loaded\");\n// Export functions for testing\nif ( true && module.exports) {\n    module.exports = {\n        showNotification,\n        handleNotificationClick,\n        getNotificationUrl,\n        trackNotificationEvent\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                /* unsupported import.meta.webpackHot */ undefined.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LFNBQVNMLFFBQVF6QyxHQUFHLENBQUMrQyxLQUFLLENBQUMsU0FBUyxDQUFDLEVBQUU7Z0JBQ3pELElBQUloRCxZQUFZOEMsWUFBWTtvQkFDeEIsTUFBTXRCLE1BQU1vQixNQUFNLENBQUNGO2dCQUN2QjtZQUNKO1FBQ0o7UUFFQS9GLFFBQVFDLEdBQUcsQ0FBQztJQUNoQixFQUFFLE9BQU9nQyxPQUFPO1FBQ1pqQyxRQUFRaUMsS0FBSyxDQUFDLGlDQUFpQ0E7SUFDbkQ7QUFDSjtBQUVBakMsUUFBUUMsR0FBRyxDQUFDO0FBRVosK0JBQStCO0FBQy9CLElBQUksS0FBNkIsSUFBSXFHLE9BQU9DLE9BQU8sRUFBRTtJQUNqREQsT0FBT0MsT0FBTyxHQUFHO1FBQ2JwRTtRQUNBSztRQUNBZTtRQUNBZDtJQUNKO0FBQ0oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vcHVibGljL3N3LXB1c2guanM/OWYwMyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogTXlUZWxtZWQgUHVzaCBOb3RpZmljYXRpb24gU2VydmljZSBXb3JrZXJcclxuICogSGFuZGxlcyBwdXNoIGV2ZW50cywgbm90aWZpY2F0aW9uIGNsaWNrcywgYW5kIGJhY2tncm91bmQgc3luY1xyXG4gKi9cclxuXHJcbi8vIFdvcmtib3ggbWFuaWZlc3QgaW5qZWN0aW9uIC0gcmVxdWlyZWQgZm9yIFBXQSBjYWNoaW5nXHJcbmltcG9ydFNjcmlwdHMoXCJodHRwczovL3N0b3JhZ2UuZ29vZ2xlYXBpcy5jb20vd29ya2JveC1jZG4vcmVsZWFzZXMvNi40LjEvd29ya2JveC1zdy5qc1wiKTtcclxuXHJcbi8vIEluamVjdCB0aGUgbWFuaWZlc3QgLSB0aGlzIHdpbGwgYmUgcmVwbGFjZWQgYnkgV29ya2JveCBkdXJpbmcgYnVpbGRcclxuaWYgKHR5cGVvZiBzZWxmLl9fV0JfTUFOSUZFU1QgIT09IFwidW5kZWZpbmVkXCIpIHtcclxuICAgIC8vIFRoaXMgZW5zdXJlcyB0aGUgbWFuaWZlc3QgaXMgaW5jbHVkZWQgaW4gdGhlIHNlcnZpY2Ugd29ya2VyXHJcbiAgICBjb25zb2xlLmxvZyhcIldvcmtib3ggbWFuaWZlc3QgbG9hZGVkXCIpO1xyXG59XHJcblxyXG4vLyBDb25zdGFudHNcclxuY29uc3QgTk9USUZJQ0FUSU9OX1RBR19QUkVGSVggPSBcIm15dGVsbWVkLVwiO1xyXG5jb25zdCBDQUNIRV9OQU1FID0gXCJteXRlbG1lZC1ub3RpZmljYXRpb25zLXYxXCI7XHJcbmNvbnN0IEFQSV9CQVNFX1VSTCA9IHNlbGYubG9jYXRpb24ub3JpZ2luO1xyXG5jb25zdCBGQUxMQkFDS19JQ09OID0gXCIvYXNzZXRzL2xvZ29zL215dGVsbWVkLWxvZ28ucG5nXCI7XHJcbmNvbnN0IEZBTExCQUNLX0JBREdFID0gXCIvYXNzZXRzL2xvZ29zL215dGVsbWVkLWxvZ28ucG5nXCI7XHJcblxyXG4vLyBOb3RpZmljYXRpb24gYWN0aW9uIGhhbmRsZXJzXHJcbmNvbnN0IE5PVElGSUNBVElPTl9BQ1RJT05TID0ge1xyXG4gICAgdmlldzogXCJWaWV3IERldGFpbHNcIixcclxuICAgIGRpc21pc3M6IFwiRGlzbWlzc1wiLFxyXG4gICAgY2FsZW5kYXI6IFwiQWRkIHRvIENhbGVuZGFyXCIsXHJcbiAgICBvcmRlcjogXCJPcmRlciBOb3dcIixcclxuICAgIHJlbmV3OiBcIlJlbmV3IE5vd1wiLFxyXG4gICAgcmVtaW5kOiBcIlJlbWluZCBMYXRlclwiLFxyXG4gICAgdHJhY2s6IFwiVHJhY2sgRGVsaXZlcnlcIixcclxuICAgIGNvbnRhY3Q6IFwiQ29udGFjdCBTdXBwb3J0XCIsXHJcbn07XHJcblxyXG4vLyBVUkwgbWFwcGluZ3MgZm9yIGRpZmZlcmVudCBub3RpZmljYXRpb24gdHlwZXNcclxuY29uc3QgTk9USUZJQ0FUSU9OX1VSTFMgPSB7XHJcbiAgICBBUFBPSU5UTUVOVF9SRU1JTkRFUl9QQVRJRU5UOiBcIi9hcHBvaW50bWVudHNcIixcclxuICAgIEFQUE9JTlRNRU5UX0NPTkZJUk1BVElPTl9QQVRJRU5UOiBcIi9hcHBvaW50bWVudHNcIixcclxuICAgIEFQUE9JTlRNRU5UX0NBTkNFTF9QQVRJRU5UOiBcIi9hcHBvaW50bWVudHNcIixcclxuICAgIEFQUE9JTlRNRU5UX0JPT0tFRF9QQVRJRU5UOiBcIi9hcHBvaW50bWVudHNcIixcclxuICAgIFBSRVNDUklQVElPTl9DUkVBVEVEOiBcIi9wcmVzY3JpcHRpb25zXCIsXHJcbiAgICBQUkVTQ1JJUFRJT05fRVhQSVJJTkc6IFwiL3ByZXNjcmlwdGlvbnNcIixcclxuICAgIFBSRVNDUklQVElPTl9PVVRfRk9SX0RFTElWRVJZOiBcIi9wcmVzY3JpcHRpb25zL2RlbGl2ZXJ5XCIsXHJcbn07XHJcblxyXG4vKipcclxuICogUHVzaCBldmVudCBoYW5kbGVyIC0gcmVjZWl2ZXMgbm90aWZpY2F0aW9ucyBmcm9tIGJhY2tlbmRcclxuICovXHJcbnNlbGYuYWRkRXZlbnRMaXN0ZW5lcihcInB1c2hcIiwgKGV2ZW50KSA9PiB7XHJcbiAgICBjb25zb2xlLmxvZyhcIlB1c2ggbm90aWZpY2F0aW9uIHJlY2VpdmVkOlwiLCBldmVudCk7XHJcblxyXG4gICAgaWYgKCFldmVudC5kYXRhKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coXCJQdXNoIGV2ZW50IGhhcyBubyBkYXRhXCIpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB0cnkge1xyXG4gICAgICAgIC8vIFBhcnNlIG5vdGlmaWNhdGlvbiBwYXlsb2FkXHJcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IGV2ZW50LmRhdGEuanNvbigpO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFwiUHVzaCBwYXlsb2FkOlwiLCBwYXlsb2FkKTtcclxuXHJcbiAgICAgICAgLy8gVmFsaWRhdGUgcGF5bG9hZFxyXG4gICAgICAgIGlmICghcGF5bG9hZC50aXRsZSB8fCAhcGF5bG9hZC5ib2R5KSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJJbnZhbGlkIHB1c2ggcGF5bG9hZCAtIG1pc3NpbmcgdGl0bGUgb3IgYm9keVwiKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gU2hvdyBub3RpZmljYXRpb25cclxuICAgICAgICBldmVudC53YWl0VW50aWwoc2hvd05vdGlmaWNhdGlvbihwYXlsb2FkKSk7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBwcm9jZXNzaW5nIHB1c2ggZXZlbnQ6XCIsIGVycm9yKTtcclxuXHJcbiAgICAgICAgLy8gU2hvdyBmYWxsYmFjayBub3RpZmljYXRpb25cclxuICAgICAgICBldmVudC53YWl0VW50aWwoc2hvd0ZhbGxiYWNrTm90aWZpY2F0aW9uKFwiTXlUZWxtZWQgTm90aWZpY2F0aW9uXCIsIFwiWW91IGhhdmUgYSBuZXcgbm90aWZpY2F0aW9uXCIpKTtcclxuICAgIH1cclxufSk7XHJcblxyXG4vKipcclxuICogTm90aWZpY2F0aW9uIGNsaWNrIGhhbmRsZXJcclxuICovXHJcbnNlbGYuYWRkRXZlbnRMaXN0ZW5lcihcIm5vdGlmaWNhdGlvbmNsaWNrXCIsIChldmVudCkgPT4ge1xyXG4gICAgY29uc29sZS5sb2coXCJOb3RpZmljYXRpb24gY2xpY2tlZDpcIiwgZXZlbnQpO1xyXG5cclxuICAgIGNvbnN0IG5vdGlmaWNhdGlvbiA9IGV2ZW50Lm5vdGlmaWNhdGlvbjtcclxuICAgIGNvbnN0IGFjdGlvbiA9IGV2ZW50LmFjdGlvbjtcclxuICAgIGNvbnN0IGRhdGEgPSBub3RpZmljYXRpb24uZGF0YSB8fCB7fTtcclxuXHJcbiAgICAvLyBDbG9zZSB0aGUgbm90aWZpY2F0aW9uXHJcbiAgICBub3RpZmljYXRpb24uY2xvc2UoKTtcclxuXHJcbiAgICAvLyBIYW5kbGUgZGlmZmVyZW50IGFjdGlvbnNcclxuICAgIGV2ZW50LndhaXRVbnRpbChoYW5kbGVOb3RpZmljYXRpb25DbGljayhhY3Rpb24sIGRhdGEpKTtcclxufSk7XHJcblxyXG4vKipcclxuICogTm90aWZpY2F0aW9uIGNsb3NlIGhhbmRsZXJcclxuICovXHJcbnNlbGYuYWRkRXZlbnRMaXN0ZW5lcihcIm5vdGlmaWNhdGlvbmNsb3NlXCIsIChldmVudCkgPT4ge1xyXG4gICAgY29uc29sZS5sb2coXCJOb3RpZmljYXRpb24gY2xvc2VkOlwiLCBldmVudCk7XHJcblxyXG4gICAgY29uc3QgZGF0YSA9IGV2ZW50Lm5vdGlmaWNhdGlvbi5kYXRhIHx8IHt9O1xyXG5cclxuICAgIC8vIFRyYWNrIG5vdGlmaWNhdGlvbiBkaXNtaXNzYWxcclxuICAgIGV2ZW50LndhaXRVbnRpbCh0cmFja05vdGlmaWNhdGlvbkV2ZW50KFwiZGlzbWlzc2VkXCIsIGRhdGEpKTtcclxufSk7XHJcblxyXG4vKipcclxuICogU2hvdyBub3RpZmljYXRpb24gd2l0aCBwcm9wZXIgZm9ybWF0dGluZ1xyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gc2hvd05vdGlmaWNhdGlvbihwYXlsb2FkKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IHtcclxuICAgICAgICAgICAgdGl0bGUsXHJcbiAgICAgICAgICAgIGJvZHksXHJcbiAgICAgICAgICAgIGljb24gPSBGQUxMQkFDS19JQ09OLFxyXG4gICAgICAgICAgICBiYWRnZSA9IEZBTExCQUNLX0JBREdFLFxyXG4gICAgICAgICAgICBpbWFnZSxcclxuICAgICAgICAgICAgdGFnLFxyXG4gICAgICAgICAgICBkYXRhID0ge30sXHJcbiAgICAgICAgICAgIGFjdGlvbnMgPSBbXSxcclxuICAgICAgICAgICAgcmVxdWlyZUludGVyYWN0aW9uID0gZmFsc2UsXHJcbiAgICAgICAgICAgIHNpbGVudCA9IGZhbHNlLFxyXG4gICAgICAgICAgICB2aWJyYXRlID0gWzIwMCwgMTAwLCAyMDBdLFxyXG4gICAgICAgIH0gPSBwYXlsb2FkO1xyXG5cclxuICAgICAgICAvLyBDcmVhdGUgbm90aWZpY2F0aW9uIG9wdGlvbnNcclxuICAgICAgICBjb25zdCBvcHRpb25zID0ge1xyXG4gICAgICAgICAgICBib2R5LFxyXG4gICAgICAgICAgICBpY29uLFxyXG4gICAgICAgICAgICBiYWRnZSxcclxuICAgICAgICAgICAgaW1hZ2UsXHJcbiAgICAgICAgICAgIHRhZzogdGFnIHx8IGAke05PVElGSUNBVElPTl9UQUdfUFJFRklYfSR7RGF0ZS5ub3coKX1gLFxyXG4gICAgICAgICAgICBkYXRhOiB7XHJcbiAgICAgICAgICAgICAgICAuLi5kYXRhLFxyXG4gICAgICAgICAgICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpLFxyXG4gICAgICAgICAgICAgICAgdXJsOiBnZXROb3RpZmljYXRpb25VcmwoZGF0YS5ub3RpZmljYXRpb25UeXBlLCBkYXRhKSxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgYWN0aW9uczogYWN0aW9ucy5tYXAoKGFjdGlvbikgPT4gKHtcclxuICAgICAgICAgICAgICAgIGFjdGlvbjogYWN0aW9uLmFjdGlvbixcclxuICAgICAgICAgICAgICAgIHRpdGxlOiBOT1RJRklDQVRJT05fQUNUSU9OU1thY3Rpb24uYWN0aW9uXSB8fCBhY3Rpb24udGl0bGUsXHJcbiAgICAgICAgICAgICAgICBpY29uOiBhY3Rpb24uaWNvbixcclxuICAgICAgICAgICAgfSkpLFxyXG4gICAgICAgICAgICByZXF1aXJlSW50ZXJhY3Rpb24sXHJcbiAgICAgICAgICAgIHNpbGVudCxcclxuICAgICAgICAgICAgdmlicmF0ZTogc2lsZW50ID8gW10gOiB2aWJyYXRlLFxyXG4gICAgICAgICAgICByZW5vdGlmeTogdHJ1ZSxcclxuICAgICAgICAgICAgcGVyc2lzdGVudDogdHJ1ZSxcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBjb25zb2xlLmxvZyhcIlNob3dpbmcgbm90aWZpY2F0aW9uIHdpdGggb3B0aW9uczpcIiwgb3B0aW9ucyk7XHJcblxyXG4gICAgICAgIC8vIFNob3cgdGhlIG5vdGlmaWNhdGlvblxyXG4gICAgICAgIGF3YWl0IHNlbGYucmVnaXN0cmF0aW9uLnNob3dOb3RpZmljYXRpb24odGl0bGUsIG9wdGlvbnMpO1xyXG5cclxuICAgICAgICAvLyBUcmFjayBub3RpZmljYXRpb24gZGVsaXZlcnlcclxuICAgICAgICBhd2FpdCB0cmFja05vdGlmaWNhdGlvbkV2ZW50KFwiZGVsaXZlcmVkXCIsIGRhdGEpO1xyXG5cclxuICAgICAgICBjb25zb2xlLmxvZyhcIk5vdGlmaWNhdGlvbiBzaG93biBzdWNjZXNzZnVsbHlcIik7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBzaG93aW5nIG5vdGlmaWNhdGlvbjpcIiwgZXJyb3IpO1xyXG4gICAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICogU2hvdyBmYWxsYmFjayBub3RpZmljYXRpb24gd2hlbiBwYXlsb2FkIGlzIGludmFsaWRcclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIHNob3dGYWxsYmFja05vdGlmaWNhdGlvbih0aXRsZSwgYm9keSkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBjb25zdCBvcHRpb25zID0ge1xyXG4gICAgICAgICAgICBib2R5LFxyXG4gICAgICAgICAgICBpY29uOiBGQUxMQkFDS19JQ09OLFxyXG4gICAgICAgICAgICBiYWRnZTogRkFMTEJBQ0tfQkFER0UsXHJcbiAgICAgICAgICAgIHRhZzogYCR7Tk9USUZJQ0FUSU9OX1RBR19QUkVGSVh9ZmFsbGJhY2tgLFxyXG4gICAgICAgICAgICBkYXRhOiB7XHJcbiAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IERhdGUubm93KCksXHJcbiAgICAgICAgICAgICAgICB0eXBlOiBcImZhbGxiYWNrXCIsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHJlcXVpcmVJbnRlcmFjdGlvbjogZmFsc2UsXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgYXdhaXQgc2VsZi5yZWdpc3RyYXRpb24uc2hvd05vdGlmaWNhdGlvbih0aXRsZSwgb3B0aW9ucyk7XHJcbiAgICAgICAgY29uc29sZS5sb2coXCJGYWxsYmFjayBub3RpZmljYXRpb24gc2hvd25cIik7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBzaG93aW5nIGZhbGxiYWNrIG5vdGlmaWNhdGlvbjpcIiwgZXJyb3IpO1xyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICogSGFuZGxlIG5vdGlmaWNhdGlvbiBjbGljayBldmVudHNcclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIGhhbmRsZU5vdGlmaWNhdGlvbkNsaWNrKGFjdGlvbiwgZGF0YSkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBjb25zb2xlLmxvZyhcIkhhbmRsaW5nIG5vdGlmaWNhdGlvbiBjbGljazpcIiwgeyBhY3Rpb24sIGRhdGEgfSk7XHJcblxyXG4gICAgICAgIC8vIFRyYWNrIGNsaWNrIGV2ZW50XHJcbiAgICAgICAgYXdhaXQgdHJhY2tOb3RpZmljYXRpb25FdmVudChcImNsaWNrZWRcIiwgeyAuLi5kYXRhLCBhY3Rpb24gfSk7XHJcblxyXG4gICAgICAgIC8vIEhhbmRsZSBzcGVjaWZpYyBhY3Rpb25zXHJcbiAgICAgICAgYXdhaXQgb3Blbk5vdGlmaWNhdGlvblVybChkYXRhKTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGhhbmRsaW5nIG5vdGlmaWNhdGlvbiBjbGljazpcIiwgZXJyb3IpO1xyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICogT3BlbiBub3RpZmljYXRpb24gVVJMIGluIGNsaWVudFxyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gb3Blbk5vdGlmaWNhdGlvblVybChkYXRhKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IHVybCA9IGRhdGEudXJsIHx8IGdldE5vdGlmaWNhdGlvblVybChkYXRhLm5vdGlmaWNhdGlvblR5cGUsIGRhdGEpO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFwiT3BlbmluZyBub3RpZmljYXRpb24gVVJMOlwiLCB1cmwpO1xyXG5cclxuICAgICAgICAvLyBGb2N1cyBleGlzdGluZyB3aW5kb3cgb3Igb3BlbiBuZXcgb25lXHJcbiAgICAgICAgY29uc3QgY2xpZW50cyA9IGF3YWl0IHNlbGYuY2xpZW50cy5tYXRjaEFsbCh7IHR5cGU6IFwid2luZG93XCIgfSk7XHJcblxyXG4gICAgICAgIGZvciAoY29uc3QgY2xpZW50IG9mIGNsaWVudHMpIHtcclxuICAgICAgICAgICAgaWYgKGNsaWVudC51cmwuaW5jbHVkZXModXJsKSAmJiBcImZvY3VzXCIgaW4gY2xpZW50KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY2xpZW50LmZvY3VzKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIE9wZW4gbmV3IHdpbmRvd1xyXG4gICAgICAgIGlmIChzZWxmLmNsaWVudHMub3BlbldpbmRvdykge1xyXG4gICAgICAgICAgICByZXR1cm4gc2VsZi5jbGllbnRzLm9wZW5XaW5kb3codXJsKTtcclxuICAgICAgICB9XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBvcGVuaW5nIG5vdGlmaWNhdGlvbiBVUkw6XCIsIGVycm9yKTtcclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEdldCBub3RpZmljYXRpb24gVVJMIGJhc2VkIG9uIHR5cGUgYW5kIGRhdGFcclxuICovXHJcbmZ1bmN0aW9uIGdldE5vdGlmaWNhdGlvblVybChub3RpZmljYXRpb25UeXBlLCBkYXRhID0ge30pIHtcclxuICAgIGlmIChkYXRhLmFjdGlvblVybCkge1xyXG4gICAgICAgIHJldHVybiBkYXRhLmFjdGlvblVybDtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBiYXNlVXJsID0gTk9USUZJQ0FUSU9OX1VSTFNbbm90aWZpY2F0aW9uVHlwZV0gfHwgXCIvZGFzaGJvYXJkXCI7XHJcblxyXG4gICAgLy8gQWRkIHNwZWNpZmljIElEcyBpZiBhdmFpbGFibGVcclxuICAgIGlmIChkYXRhLmFwcG9pbnRtZW50SWQgJiYgYmFzZVVybC5pbmNsdWRlcyhcImFwcG9pbnRtZW50c1wiKSkge1xyXG4gICAgICAgIHJldHVybiBgJHtiYXNlVXJsfS8ke2RhdGEuYXBwb2ludG1lbnRJZH1gO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChkYXRhLnByZXNjcmlwdGlvbklkICYmIGJhc2VVcmwuaW5jbHVkZXMoXCJwcmVzY3JpcHRpb25zXCIpKSB7XHJcbiAgICAgICAgcmV0dXJuIGAke2Jhc2VVcmx9LyR7ZGF0YS5wcmVzY3JpcHRpb25JZH1gO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBiYXNlVXJsO1xyXG59XHJcblxyXG4vKipcclxuICogVHJhY2sgbm90aWZpY2F0aW9uIGV2ZW50cyBmb3IgYW5hbHl0aWNzXHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiB0cmFja05vdGlmaWNhdGlvbkV2ZW50KGV2ZW50LCBkYXRhKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFwiVHJhY2tpbmcgbm90aWZpY2F0aW9uIGV2ZW50OlwiLCB7IGV2ZW50LCBkYXRhIH0pO1xyXG5cclxuICAgICAgICAvLyBTdG9yZSBldmVudCBsb2NhbGx5XHJcbiAgICAgICAgY29uc3QgZXZlbnREYXRhID0ge1xyXG4gICAgICAgICAgICBldmVudCxcclxuICAgICAgICAgICAgbm90aWZpY2F0aW9uVHlwZTogZGF0YS5ub3RpZmljYXRpb25UeXBlLFxyXG4gICAgICAgICAgICB0aW1lc3RhbXA6IERhdGUubm93KCksXHJcbiAgICAgICAgICAgIHVzZXJJZDogZGF0YS51c2VySWQsXHJcbiAgICAgICAgICAgIGFwcG9pbnRtZW50SWQ6IGRhdGEuYXBwb2ludG1lbnRJZCxcclxuICAgICAgICAgICAgcHJlc2NyaXB0aW9uSWQ6IGRhdGEucHJlc2NyaXB0aW9uSWQsXHJcbiAgICAgICAgICAgIGFjdGlvbjogZGF0YS5hY3Rpb24sXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLy8gU3RvcmUgaW4gSW5kZXhlZERCIG9yIGxvY2FsU3RvcmFnZVxyXG4gICAgICAgIGF3YWl0IHN0b3JlTm90aWZpY2F0aW9uRXZlbnQoZXZlbnREYXRhKTtcclxuXHJcbiAgICAgICAgLy8gVHJ5IHRvIHNlbmQgdG8gYmFja2VuZCAod2l0aCBiYWNrZ3JvdW5kIHN5bmMgZmFsbGJhY2spXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgYXdhaXQgc2VuZEV2ZW50VG9CYWNrZW5kKGV2ZW50RGF0YSk7XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJGYWlsZWQgdG8gc2VuZCBldmVudCB0byBiYWNrZW5kLCB3aWxsIHJldHJ5IGxhdGVyOlwiLCBlcnJvcik7XHJcbiAgICAgICAgICAgIC8vIENvdWxkIGltcGxlbWVudCBiYWNrZ3JvdW5kIHN5bmMgaGVyZVxyXG4gICAgICAgIH1cclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIHRyYWNraW5nIG5vdGlmaWNhdGlvbiBldmVudDpcIiwgZXJyb3IpO1xyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICogU3RvcmUgbm90aWZpY2F0aW9uIGV2ZW50IGxvY2FsbHlcclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIHN0b3JlTm90aWZpY2F0aW9uRXZlbnQoZXZlbnREYXRhKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIC8vIEZvciBzaW1wbGljaXR5LCB1c2luZyBjYWNoZSBBUEkgdG8gc3RvcmUgZXZlbnRzXHJcbiAgICAgICAgLy8gSW4gcHJvZHVjdGlvbiwgeW91IG1pZ2h0IHdhbnQgdG8gdXNlIEluZGV4ZWREQlxyXG4gICAgICAgIGNvbnN0IGNhY2hlID0gYXdhaXQgY2FjaGVzLm9wZW4oQ0FDSEVfTkFNRSk7XHJcbiAgICAgICAgY29uc3QgZXZlbnRLZXkgPSBgZXZlbnQtJHtldmVudERhdGEudGltZXN0YW1wfWA7XHJcblxyXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gbmV3IFJlc3BvbnNlKEpTT04uc3RyaW5naWZ5KGV2ZW50RGF0YSksIHtcclxuICAgICAgICAgICAgaGVhZGVyczogeyBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9LFxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBhd2FpdCBjYWNoZS5wdXQoZXZlbnRLZXksIHJlc3BvbnNlKTtcclxuICAgICAgICBjb25zb2xlLmxvZyhcIk5vdGlmaWNhdGlvbiBldmVudCBzdG9yZWQgbG9jYWxseVwiKTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIHN0b3Jpbmcgbm90aWZpY2F0aW9uIGV2ZW50OlwiLCBlcnJvcik7XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBTZW5kIGV2ZW50IHRvIGJhY2tlbmRcclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIHNlbmRFdmVudFRvQmFja2VuZChldmVudERhdGEpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtBUElfQkFTRV9VUkx9L2FwaS9ub3RpZmljYXRpb24tZXZlbnRzYCwge1xyXG4gICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxyXG4gICAgICAgICAgICBoZWFkZXJzOiB7XHJcbiAgICAgICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoZXZlbnREYXRhKSxcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEhUVFAgJHtyZXNwb25zZS5zdGF0dXN9OiAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zb2xlLmxvZyhcIkV2ZW50IHNlbnQgdG8gYmFja2VuZCBzdWNjZXNzZnVsbHlcIik7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBzZW5kaW5nIGV2ZW50IHRvIGJhY2tlbmQ6XCIsIGVycm9yKTtcclxuICAgICAgICB0aHJvdyBlcnJvcjtcclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEJhY2tncm91bmQgc3luYyBmb3Igb2ZmbGluZSBldmVudHMgKG9wdGlvbmFsKVxyXG4gKi9cclxuc2VsZi5hZGRFdmVudExpc3RlbmVyKFwic3luY1wiLCAoZXZlbnQpID0+IHtcclxuICAgIGlmIChldmVudC50YWcgPT09IFwibm90aWZpY2F0aW9uLWV2ZW50cy1zeW5jXCIpIHtcclxuICAgICAgICBjb25zb2xlLmxvZyhcIkJhY2tncm91bmQgc3luYyB0cmlnZ2VyZWQgZm9yIG5vdGlmaWNhdGlvbiBldmVudHNcIik7XHJcbiAgICAgICAgZXZlbnQud2FpdFVudGlsKHN5bmNOb3RpZmljYXRpb25FdmVudHMoKSk7XHJcbiAgICB9XHJcbn0pO1xyXG5cclxuLyoqXHJcbiAqIFN5bmMgc3RvcmVkIG5vdGlmaWNhdGlvbiBldmVudHMgd2hlbiBvbmxpbmVcclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIHN5bmNOb3RpZmljYXRpb25FdmVudHMoKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IGNhY2hlID0gYXdhaXQgY2FjaGVzLm9wZW4oQ0FDSEVfTkFNRSk7XHJcbiAgICAgICAgY29uc3Qga2V5cyA9IGF3YWl0IGNhY2hlLmtleXMoKTtcclxuXHJcbiAgICAgICAgZm9yIChjb25zdCByZXF1ZXN0IG9mIGtleXMpIHtcclxuICAgICAgICAgICAgaWYgKHJlcXVlc3QudXJsLmluY2x1ZGVzKFwiZXZlbnQtXCIpKSB7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY2FjaGUubWF0Y2gocmVxdWVzdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXZlbnREYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBhd2FpdCBzZW5kRXZlbnRUb0JhY2tlbmQoZXZlbnREYXRhKTtcclxuICAgICAgICAgICAgICAgICAgICBhd2FpdCBjYWNoZS5kZWxldGUocmVxdWVzdCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiU3luY2VkIG5vdGlmaWNhdGlvbiBldmVudDpcIiwgZXZlbnREYXRhLmV2ZW50KTtcclxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIHN5bmNpbmcgZXZlbnQ6XCIsIGVycm9yKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGR1cmluZyBub3RpZmljYXRpb24gZXZlbnRzIHN5bmM6XCIsIGVycm9yKTtcclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIENsZWFuIHVwIG9sZCBub3RpZmljYXRpb24gZXZlbnRzXHJcbiAqL1xyXG5zZWxmLmFkZEV2ZW50TGlzdGVuZXIoXCJhY3RpdmF0ZVwiLCAoZXZlbnQpID0+IHtcclxuICAgIGV2ZW50LndhaXRVbnRpbChjbGVhbnVwT2xkRXZlbnRzKCkpO1xyXG59KTtcclxuXHJcbmFzeW5jIGZ1bmN0aW9uIGNsZWFudXBPbGRFdmVudHMoKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IGNhY2hlID0gYXdhaXQgY2FjaGVzLm9wZW4oQ0FDSEVfTkFNRSk7XHJcbiAgICAgICAgY29uc3Qga2V5cyA9IGF3YWl0IGNhY2hlLmtleXMoKTtcclxuICAgICAgICBjb25zdCBvbmVXZWVrQWdvID0gRGF0ZS5ub3coKSAtIDcgKiAyNCAqIDYwICogNjAgKiAxMDAwO1xyXG5cclxuICAgICAgICBmb3IgKGNvbnN0IHJlcXVlc3Qgb2Yga2V5cykge1xyXG4gICAgICAgICAgICBpZiAocmVxdWVzdC51cmwuaW5jbHVkZXMoXCJldmVudC1cIikpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHRpbWVzdGFtcCA9IHBhcnNlSW50KHJlcXVlc3QudXJsLnNwbGl0KFwiZXZlbnQtXCIpWzFdKTtcclxuICAgICAgICAgICAgICAgIGlmICh0aW1lc3RhbXAgPCBvbmVXZWVrQWdvKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgY2FjaGUuZGVsZXRlKHJlcXVlc3QpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zb2xlLmxvZyhcIkNsZWFuZWQgdXAgb2xkIG5vdGlmaWNhdGlvbiBldmVudHNcIik7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBjbGVhbmluZyB1cCBvbGQgZXZlbnRzOlwiLCBlcnJvcik7XHJcbiAgICB9XHJcbn1cclxuXHJcbmNvbnNvbGUubG9nKFwiTXlUZWxtZWQgUHVzaCBOb3RpZmljYXRpb24gU2VydmljZSBXb3JrZXIgbG9hZGVkXCIpO1xyXG5cclxuLy8gRXhwb3J0IGZ1bmN0aW9ucyBmb3IgdGVzdGluZ1xyXG5pZiAodHlwZW9mIG1vZHVsZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBtb2R1bGUuZXhwb3J0cykge1xyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgICAgICAgc2hvd05vdGlmaWNhdGlvbixcclxuICAgICAgICBoYW5kbGVOb3RpZmljYXRpb25DbGljayxcclxuICAgICAgICBnZXROb3RpZmljYXRpb25VcmwsXHJcbiAgICAgICAgdHJhY2tOb3RpZmljYXRpb25FdmVudCxcclxuICAgIH07XHJcbn1cclxuIl0sIm5hbWVzIjpbImltcG9ydFNjcmlwdHMiLCJzZWxmIiwiX19XQl9NQU5JRkVTVCIsImNvbnNvbGUiLCJsb2ciLCJOT1RJRklDQVRJT05fVEFHX1BSRUZJWCIsIkNBQ0hFX05BTUUiLCJBUElfQkFTRV9VUkwiLCJsb2NhdGlvbiIsIm9yaWdpbiIsIkZBTExCQUNLX0lDT04iLCJGQUxMQkFDS19CQURHRSIsIk5PVElGSUNBVElPTl9BQ1RJT05TIiwidmlldyIsImRpc21pc3MiLCJjYWxlbmRhciIsIm9yZGVyIiwicmVuZXciLCJyZW1pbmQiLCJ0cmFjayIsImNvbnRhY3QiLCJOT1RJRklDQVRJT05fVVJMUyIsIkFQUE9JTlRNRU5UX1JFTUlOREVSX1BBVElFTlQiLCJBUFBPSU5UTUVOVF9DT05GSVJNQVRJT05fUEFUSUVOVCIsIkFQUE9JTlRNRU5UX0NBTkNFTF9QQVRJRU5UIiwiQVBQT0lOVE1FTlRfQk9PS0VEX1BBVElFTlQiLCJQUkVTQ1JJUFRJT05fQ1JFQVRFRCIsIlBSRVNDUklQVElPTl9FWFBJUklORyIsIlBSRVNDUklQVElPTl9PVVRfRk9SX0RFTElWRVJZIiwiYWRkRXZlbnRMaXN0ZW5lciIsImV2ZW50IiwiZGF0YSIsInBheWxvYWQiLCJqc29uIiwidGl0bGUiLCJib2R5IiwiZXJyb3IiLCJ3YWl0VW50aWwiLCJzaG93Tm90aWZpY2F0aW9uIiwic2hvd0ZhbGxiYWNrTm90aWZpY2F0aW9uIiwibm90aWZpY2F0aW9uIiwiYWN0aW9uIiwiY2xvc2UiLCJoYW5kbGVOb3RpZmljYXRpb25DbGljayIsInRyYWNrTm90aWZpY2F0aW9uRXZlbnQiLCJpY29uIiwiYmFkZ2UiLCJpbWFnZSIsInRhZyIsImFjdGlvbnMiLCJyZXF1aXJlSW50ZXJhY3Rpb24iLCJzaWxlbnQiLCJ2aWJyYXRlIiwib3B0aW9ucyIsIkRhdGUiLCJub3ciLCJ0aW1lc3RhbXAiLCJ1cmwiLCJnZXROb3RpZmljYXRpb25VcmwiLCJub3RpZmljYXRpb25UeXBlIiwibWFwIiwicmVub3RpZnkiLCJwZXJzaXN0ZW50IiwicmVnaXN0cmF0aW9uIiwidHlwZSIsIm9wZW5Ob3RpZmljYXRpb25VcmwiLCJjbGllbnRzIiwibWF0Y2hBbGwiLCJjbGllbnQiLCJpbmNsdWRlcyIsImZvY3VzIiwib3BlbldpbmRvdyIsImFjdGlvblVybCIsImJhc2VVcmwiLCJhcHBvaW50bWVudElkIiwicHJlc2NyaXB0aW9uSWQiLCJldmVudERhdGEiLCJ1c2VySWQiLCJzdG9yZU5vdGlmaWNhdGlvbkV2ZW50Iiwic2VuZEV2ZW50VG9CYWNrZW5kIiwiY2FjaGUiLCJjYWNoZXMiLCJvcGVuIiwiZXZlbnRLZXkiLCJyZXNwb25zZSIsIlJlc3BvbnNlIiwiSlNPTiIsInN0cmluZ2lmeSIsImhlYWRlcnMiLCJwdXQiLCJmZXRjaCIsIm1ldGhvZCIsIm9rIiwiRXJyb3IiLCJzdGF0dXMiLCJzdGF0dXNUZXh0Iiwic3luY05vdGlmaWNhdGlvbkV2ZW50cyIsImtleXMiLCJyZXF1ZXN0IiwibWF0Y2giLCJkZWxldGUiLCJjbGVhbnVwT2xkRXZlbnRzIiwib25lV2Vla0FnbyIsInBhcnNlSW50Iiwic3BsaXQiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./public/sw-push.js\n"));

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			if (cachedModule.error !== undefined) throw cachedModule.error;
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		var threw = true;
/******/ 		try {
/******/ 			__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 			threw = false;
/******/ 		} finally {
/******/ 			if(threw) delete __webpack_module_cache__[moduleId];
/******/ 		}
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/trusted types policy */
/******/ 	!function() {
/******/ 		var policy;
/******/ 		__webpack_require__.tt = function() {
/******/ 			// Create Trusted Type policy if Trusted Types are available and the policy doesn't exist yet.
/******/ 			if (policy === undefined) {
/******/ 				policy = {
/******/ 					createScript: function(script) { return script; }
/******/ 				};
/******/ 				if (typeof trustedTypes !== "undefined" && trustedTypes.createPolicy) {
/******/ 					policy = trustedTypes.createPolicy("nextjs#bundler", policy);
/******/ 				}
/******/ 			}
/******/ 			return policy;
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/trusted types script */
/******/ 	!function() {
/******/ 		__webpack_require__.ts = function(script) { return __webpack_require__.tt().createScript(script); };
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/react refresh */
/******/ 	!function() {
/******/ 		if (__webpack_require__.i) {
/******/ 		__webpack_require__.i.push(function(options) {
/******/ 			var originalFactory = options.factory;
/******/ 			options.factory = function(moduleObject, moduleExports, webpackRequire) {
/******/ 				var hasRefresh = typeof self !== "undefined" && !!self.$RefreshInterceptModuleExecution$;
/******/ 				var cleanup = hasRefresh ? self.$RefreshInterceptModuleExecution$(moduleObject.id) : function() {};
/******/ 				try {
/******/ 					originalFactory.call(this, moduleObject, moduleExports, webpackRequire);
/******/ 				} finally {
/******/ 					cleanup();
/******/ 				}
/******/ 			}
/******/ 		})
/******/ 		}
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/compat */
/******/ 	
/******/ 	
/******/ 	// noop fns to prevent runtime errors during initialization
/******/ 	if (typeof self !== "undefined") {
/******/ 		self.$RefreshReg$ = function () {};
/******/ 		self.$RefreshSig$ = function () {
/******/ 			return function (type) {
/******/ 				return type;
/******/ 			};
/******/ 		};
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./public/sw-push.js");
/******/ 	
/******/ })()
;