/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (function() { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./public/sw-push.js":
/*!***************************!*\
  !*** ./public/sw-push.js ***!
  \***************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("/**\r\n * MyTelmed Push Notification Service Worker\r\n * Handles push events, notification clicks, and background sync\r\n */ // Workbox manifest injection - required for PWA caching\n\nimportScripts(\"https://storage.googleapis.com/workbox-cdn/releases/6.4.1/workbox-sw.js\");\n// Inject the manifest - this will be replaced by Workbox during build\nif (typeof [] !== \"undefined\") {\n    // This ensures the manifest is included in the service worker\n    console.log(\"Workbox manifest loaded\");\n}\n// Constants\nconst NOTIFICATION_TAG_PREFIX = \"mytelmed-\";\nconst CACHE_NAME = \"mytelmed-notifications-v1\";\nconst FALLBACK_ICON = \"/assets/logos/mytelmed-logo.png\";\nconst FALLBACK_BADGE = \"/assets/logos/mytelmed-logo.png\";\n// URL mappings for different notification types\nconst NOTIFICATION_URLS = {\n    APPOINTMENT_REMINDER_PATIENT: \"/patient/appointment\",\n    APPOINTMENT_CONFIRMATION_PATIENT: \"/patient/appointment\",\n    APPOINTMENT_CANCEL_PATIENT: \"/patient/appointment\",\n    APPOINTMENT_BOOKED_PATIENT: \"/patient/appointment\",\n    PRESCRIPTION_CREATED: \"/patient/prescription\",\n    PRESCRIPTION_EXPIRING: \"/patient/prescription\"\n};\n/**\r\n * Push event handler - receives notifications from backend\r\n */ self.addEventListener(\"push\", (event)=>{\n    console.log(\"Push notification received:\", event);\n    if (!event.data) {\n        console.log(\"Push event has no data\");\n        return;\n    }\n    try {\n        // Parse notification payload\n        const payload = event.data.json();\n        console.log(\"Push payload:\", payload);\n        // Validate payload\n        if (!payload.title || !payload.body) {\n            console.error(\"Invalid push payload - missing title or body\");\n            return;\n        }\n        // Show notification\n        event.waitUntil(showNotification(payload));\n    } catch (error) {\n        console.error(\"Error processing push event:\", error);\n        // Show fallback notification\n        event.waitUntil(showFallbackNotification(\"MyTelmed Notification\", \"You have a new notification\"));\n    }\n});\n/**\r\n * Notification click handler\r\n */ self.addEventListener(\"notificationclick\", (event)=>{\n    console.log(\"Notification clicked:\", event);\n    const notification = event.notification;\n    const action = event.action;\n    const data = notification.data || {};\n    // Close the notification\n    notification.close();\n    // Handle different actions\n    event.waitUntil(handleNotificationClick(action, data));\n});\n/**\r\n * Notification close handler\r\n */ self.addEventListener(\"notificationclose\", (event)=>{\n    console.log(\"Notification closed:\", event);\n    const data = event.notification.data || {};\n    // Track notification dismissal\n    event.waitUntil(trackNotificationEvent(\"dismissed\", data));\n});\n/**\r\n * Show notification with proper formatting\r\n */ async function showNotification(payload) {\n    try {\n        const { title, body, icon = FALLBACK_ICON, badge = FALLBACK_BADGE, image, tag, data = {}, actions = [], requireInteraction = false, silent = false, vibrate = [\n            200,\n            100,\n            200\n        ] } = payload;\n        var _data_url;\n        // Create notification options\n        const options = {\n            body,\n            icon,\n            badge,\n            image,\n            tag: tag || \"\".concat(NOTIFICATION_TAG_PREFIX).concat(Date.now()),\n            data: {\n                ...data,\n                timestamp: Date.now(),\n                url: (_data_url = data.url) !== null && _data_url !== void 0 ? _data_url : getNotificationUrl(data.notificationType || payload.tag, data)\n            },\n            actions: actions.map((action)=>({\n                    action: action.action,\n                    title: action.title,\n                    icon: action.icon\n                })),\n            requireInteraction,\n            silent,\n            vibrate: silent ? [] : vibrate,\n            renotify: true,\n            persistent: true\n        };\n        console.log(\"Showing notification with options:\", options);\n        // Show the notification\n        await self.registration.showNotification(title, options);\n        // Track notification delivery\n        await trackNotificationEvent(\"delivered\", data);\n        console.log(\"Notification shown successfully\");\n    } catch (error) {\n        console.error(\"Error showing notification:\", error);\n        throw error;\n    }\n}\n/**\r\n * Show fallback notification when payload is invalid\r\n */ async function showFallbackNotification(title, body) {\n    try {\n        const options = {\n            body,\n            icon: FALLBACK_ICON,\n            badge: FALLBACK_BADGE,\n            tag: \"\".concat(NOTIFICATION_TAG_PREFIX, \"fallback\"),\n            data: {\n                timestamp: Date.now(),\n                type: \"fallback\"\n            },\n            requireInteraction: false\n        };\n        await self.registration.showNotification(title, options);\n        console.log(\"Fallback notification shown\");\n    } catch (error) {\n        console.error(\"Error showing fallback notification:\", error);\n    }\n}\n/**\r\n * Handle notification click events\r\n */ async function handleNotificationClick(action, data) {\n    try {\n        console.log(\"Handling notification click:\", {\n            action,\n            data\n        });\n        // Track click event\n        await trackNotificationEvent(\"clicked\", {\n            ...data,\n            action\n        });\n        // Handle specific actions\n        await openNotificationUrl(data);\n    } catch (error) {\n        console.error(\"Error handling notification click:\", error);\n    }\n}\n/**\r\n * Open notification URL in client\r\n */ async function openNotificationUrl(data) {\n    try {\n        const url = data.url || getNotificationUrl(data.notificationType, data);\n        console.log(\"Opening notification URL:\", url);\n        // Focus existing window or open new one\n        const clients = await self.clients.matchAll({\n            type: \"window\"\n        });\n        for (const client of clients){\n            if (client.url.includes(url) && \"focus\" in client) {\n                return client.focus();\n            }\n        }\n        // Open new window\n        if (self.clients.openWindow) {\n            return self.clients.openWindow(url);\n        }\n    } catch (error) {\n        console.error(\"Error opening notification URL:\", error);\n    }\n}\n/**\r\n * Get notification URL based on type and data\r\n */ function getNotificationUrl(notificationType) {\n    let data = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    console.log(\"Getting notification URL for:\", {\n        notificationType,\n        data\n    });\n    if (data.url) {\n        return data.url;\n    }\n    const baseUrl = NOTIFICATION_URLS[notificationType] || \"/\";\n    // Add specific IDs if available\n    if (data.appointmentId && baseUrl.includes(\"appointments\")) {\n        return \"\".concat(baseUrl, \"/\").concat(data.appointmentId);\n    }\n    if (data.prescriptionId && baseUrl.includes(\"prescriptions\")) {\n        return \"\".concat(baseUrl, \"/\").concat(data.prescriptionId);\n    }\n    return baseUrl;\n}\n/**\r\n * Track notification events for analytics\r\n */ async function trackNotificationEvent(event, data) {\n    try {\n        console.log(\"Tracking notification event:\", {\n            event,\n            data\n        });\n        // Store event locally\n        const eventData = {\n            event,\n            notificationType: data.notificationType,\n            timestamp: Date.now(),\n            userId: data.userId,\n            appointmentId: data.appointmentId,\n            prescriptionId: data.prescriptionId,\n            action: data.action\n        };\n        // Store in IndexedDB or localStorage\n        await storeNotificationEvent(eventData);\n    } catch (error) {\n        console.error(\"Error tracking notification event:\", error);\n    }\n}\n/**\r\n * Store notification event locally\r\n */ async function storeNotificationEvent(eventData) {\n    try {\n        // For simplicity, using cache API to store events\n        // In production, you might want to use IndexedDB\n        const cache = await caches.open(CACHE_NAME);\n        const eventKey = \"event-\".concat(eventData.timestamp);\n        const response = new Response(JSON.stringify(eventData), {\n            headers: {\n                \"Content-Type\": \"application/json\"\n            }\n        });\n        await cache.put(eventKey, response);\n        console.log(\"Notification event stored locally\");\n    } catch (error) {\n        console.error(\"Error storing notification event:\", error);\n    }\n}\n/**\r\n * Background sync for offline events (optional)\r\n */ self.addEventListener(\"sync\", (event)=>{\n    if (event.tag === \"notification-events-sync\") {\n        console.log(\"Background sync triggered for notification events\");\n        event.waitUntil(syncNotificationEvents());\n    }\n});\n/**\r\n * Sync stored notification events when online\r\n */ async function syncNotificationEvents() {\n    try {\n        const cache = await caches.open(CACHE_NAME);\n        const keys = await cache.keys();\n        for (const request of keys){\n            if (request.url.includes(\"event-\")) {\n                try {\n                    const response = await cache.match(request);\n                    const eventData = await response.json();\n                    await cache.delete(request);\n                    console.log(\"Synced notification event:\", eventData.event);\n                } catch (error) {\n                    console.error(\"Error syncing event:\", error);\n                }\n            }\n        }\n    } catch (error) {\n        console.error(\"Error during notification events sync:\", error);\n    }\n}\n/**\r\n * Clean up old notification events\r\n */ self.addEventListener(\"activate\", (event)=>{\n    event.waitUntil(cleanupOldEvents());\n});\nasync function cleanupOldEvents() {\n    try {\n        const cache = await caches.open(CACHE_NAME);\n        const keys = await cache.keys();\n        const oneWeekAgo = Date.now() - 7 * 24 * 60 * 60 * 1000;\n        for (const request of keys){\n            if (request.url.includes(\"event-\")) {\n                const timestamp = parseInt(request.url.split(\"event-\")[1]);\n                if (timestamp < oneWeekAgo) {\n                    await cache.delete(request);\n                }\n            }\n        }\n        console.log(\"Cleaned up old notification events\");\n    } catch (error) {\n        console.error(\"Error cleaning up old events:\", error);\n    }\n}\nconsole.log(\"MyTelmed Push Notification Service Worker loaded\");\n// Export functions for testing\nif ( true && module.exports) {\n    module.exports = {\n        showNotification,\n        handleNotificationClick,\n        getNotificationUrl,\n        trackNotificationEvent\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                /* unsupported import.meta.webpackHot */ undefined.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O0FBRUEsZUFBZUE7SUFDWCxJQUFJO1FBQ0EsTUFBTWYsUUFBUSxNQUFNQyxPQUFPQyxJQUFJLENBQUM3RDtRQUNoQyxNQUFNc0UsT0FBTyxNQUFNWCxNQUFNVyxJQUFJO1FBQzdCLE1BQU1LLGFBQWF4QyxLQUFLQyxHQUFHLEtBQUssSUFBSSxLQUFLLEtBQUssS0FBSztRQUVuRCxLQUFLLE1BQU1tQyxXQUFXRCxLQUFNO1lBQ3hCLElBQUlDLFFBQVFqQyxHQUFHLENBQUNZLFFBQVEsQ0FBQyxXQUFXO2dCQUNoQyxNQUFNYixZQUFZdUMsU0FBU0wsUUFBUWpDLEdBQUcsQ0FBQ3VDLEtBQUssQ0FBQyxTQUFTLENBQUMsRUFBRTtnQkFDekQsSUFBSXhDLFlBQVlzQyxZQUFZO29CQUN4QixNQUFNaEIsTUFBTWMsTUFBTSxDQUFDRjtnQkFDdkI7WUFDSjtRQUNKO1FBRUExRSxRQUFRQyxHQUFHLENBQUM7SUFDaEIsRUFBRSxPQUFPbUIsT0FBTztRQUNacEIsUUFBUW9CLEtBQUssQ0FBQyxpQ0FBaUNBO0lBQ25EO0FBQ0o7QUFFQXBCLFFBQVFDLEdBQUcsQ0FBQztBQUVaLCtCQUErQjtBQUMvQixJQUFJLEtBQTZCLElBQUlnRixPQUFPQyxPQUFPLEVBQUU7SUFDakRELE9BQU9DLE9BQU8sR0FBRztRQUNiNUQ7UUFDQUs7UUFDQWU7UUFDQWQ7SUFDSjtBQUNKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3B1YmxpYy9zdy1wdXNoLmpzPzlmMDMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIE15VGVsbWVkIFB1c2ggTm90aWZpY2F0aW9uIFNlcnZpY2UgV29ya2VyXHJcbiAqIEhhbmRsZXMgcHVzaCBldmVudHMsIG5vdGlmaWNhdGlvbiBjbGlja3MsIGFuZCBiYWNrZ3JvdW5kIHN5bmNcclxuICovXHJcblxyXG4vLyBXb3JrYm94IG1hbmlmZXN0IGluamVjdGlvbiAtIHJlcXVpcmVkIGZvciBQV0EgY2FjaGluZ1xyXG5pbXBvcnRTY3JpcHRzKFwiaHR0cHM6Ly9zdG9yYWdlLmdvb2dsZWFwaXMuY29tL3dvcmtib3gtY2RuL3JlbGVhc2VzLzYuNC4xL3dvcmtib3gtc3cuanNcIik7XHJcblxyXG4vLyBJbmplY3QgdGhlIG1hbmlmZXN0IC0gdGhpcyB3aWxsIGJlIHJlcGxhY2VkIGJ5IFdvcmtib3ggZHVyaW5nIGJ1aWxkXHJcbmlmICh0eXBlb2Ygc2VsZi5fX1dCX01BTklGRVNUICE9PSBcInVuZGVmaW5lZFwiKSB7XHJcbiAgICAvLyBUaGlzIGVuc3VyZXMgdGhlIG1hbmlmZXN0IGlzIGluY2x1ZGVkIGluIHRoZSBzZXJ2aWNlIHdvcmtlclxyXG4gICAgY29uc29sZS5sb2coXCJXb3JrYm94IG1hbmlmZXN0IGxvYWRlZFwiKTtcclxufVxyXG5cclxuLy8gQ29uc3RhbnRzXHJcbmNvbnN0IE5PVElGSUNBVElPTl9UQUdfUFJFRklYID0gXCJteXRlbG1lZC1cIjtcclxuY29uc3QgQ0FDSEVfTkFNRSA9IFwibXl0ZWxtZWQtbm90aWZpY2F0aW9ucy12MVwiO1xyXG5jb25zdCBGQUxMQkFDS19JQ09OID0gXCIvYXNzZXRzL2xvZ29zL215dGVsbWVkLWxvZ28ucG5nXCI7XHJcbmNvbnN0IEZBTExCQUNLX0JBREdFID0gXCIvYXNzZXRzL2xvZ29zL215dGVsbWVkLWxvZ28ucG5nXCI7XHJcblxyXG4vLyBVUkwgbWFwcGluZ3MgZm9yIGRpZmZlcmVudCBub3RpZmljYXRpb24gdHlwZXNcclxuY29uc3QgTk9USUZJQ0FUSU9OX1VSTFMgPSB7XHJcbiAgICBBUFBPSU5UTUVOVF9SRU1JTkRFUl9QQVRJRU5UOiBcIi9wYXRpZW50L2FwcG9pbnRtZW50XCIsXHJcbiAgICBBUFBPSU5UTUVOVF9DT05GSVJNQVRJT05fUEFUSUVOVDogXCIvcGF0aWVudC9hcHBvaW50bWVudFwiLFxyXG4gICAgQVBQT0lOVE1FTlRfQ0FOQ0VMX1BBVElFTlQ6IFwiL3BhdGllbnQvYXBwb2ludG1lbnRcIixcclxuICAgIEFQUE9JTlRNRU5UX0JPT0tFRF9QQVRJRU5UOiBcIi9wYXRpZW50L2FwcG9pbnRtZW50XCIsXHJcbiAgICBQUkVTQ1JJUFRJT05fQ1JFQVRFRDogXCIvcGF0aWVudC9wcmVzY3JpcHRpb25cIixcclxuICAgIFBSRVNDUklQVElPTl9FWFBJUklORzogXCIvcGF0aWVudC9wcmVzY3JpcHRpb25cIixcclxufTtcclxuXHJcbi8qKlxyXG4gKiBQdXNoIGV2ZW50IGhhbmRsZXIgLSByZWNlaXZlcyBub3RpZmljYXRpb25zIGZyb20gYmFja2VuZFxyXG4gKi9cclxuc2VsZi5hZGRFdmVudExpc3RlbmVyKFwicHVzaFwiLCAoZXZlbnQpID0+IHtcclxuICAgIGNvbnNvbGUubG9nKFwiUHVzaCBub3RpZmljYXRpb24gcmVjZWl2ZWQ6XCIsIGV2ZW50KTtcclxuXHJcbiAgICBpZiAoIWV2ZW50LmRhdGEpIHtcclxuICAgICAgICBjb25zb2xlLmxvZyhcIlB1c2ggZXZlbnQgaGFzIG5vIGRhdGFcIik7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHRyeSB7XHJcbiAgICAgICAgLy8gUGFyc2Ugbm90aWZpY2F0aW9uIHBheWxvYWRcclxuICAgICAgICBjb25zdCBwYXlsb2FkID0gZXZlbnQuZGF0YS5qc29uKCk7XHJcbiAgICAgICAgY29uc29sZS5sb2coXCJQdXNoIHBheWxvYWQ6XCIsIHBheWxvYWQpO1xyXG5cclxuICAgICAgICAvLyBWYWxpZGF0ZSBwYXlsb2FkXHJcbiAgICAgICAgaWYgKCFwYXlsb2FkLnRpdGxlIHx8ICFwYXlsb2FkLmJvZHkpIHtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkludmFsaWQgcHVzaCBwYXlsb2FkIC0gbWlzc2luZyB0aXRsZSBvciBib2R5XCIpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBTaG93IG5vdGlmaWNhdGlvblxyXG4gICAgICAgIGV2ZW50LndhaXRVbnRpbChzaG93Tm90aWZpY2F0aW9uKHBheWxvYWQpKTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIHByb2Nlc3NpbmcgcHVzaCBldmVudDpcIiwgZXJyb3IpO1xyXG5cclxuICAgICAgICAvLyBTaG93IGZhbGxiYWNrIG5vdGlmaWNhdGlvblxyXG4gICAgICAgIGV2ZW50LndhaXRVbnRpbChzaG93RmFsbGJhY2tOb3RpZmljYXRpb24oXCJNeVRlbG1lZCBOb3RpZmljYXRpb25cIiwgXCJZb3UgaGF2ZSBhIG5ldyBub3RpZmljYXRpb25cIikpO1xyXG4gICAgfVxyXG59KTtcclxuXHJcbi8qKlxyXG4gKiBOb3RpZmljYXRpb24gY2xpY2sgaGFuZGxlclxyXG4gKi9cclxuc2VsZi5hZGRFdmVudExpc3RlbmVyKFwibm90aWZpY2F0aW9uY2xpY2tcIiwgKGV2ZW50KSA9PiB7XHJcbiAgICBjb25zb2xlLmxvZyhcIk5vdGlmaWNhdGlvbiBjbGlja2VkOlwiLCBldmVudCk7XHJcblxyXG4gICAgY29uc3Qgbm90aWZpY2F0aW9uID0gZXZlbnQubm90aWZpY2F0aW9uO1xyXG4gICAgY29uc3QgYWN0aW9uID0gZXZlbnQuYWN0aW9uO1xyXG4gICAgY29uc3QgZGF0YSA9IG5vdGlmaWNhdGlvbi5kYXRhIHx8IHt9O1xyXG5cclxuICAgIC8vIENsb3NlIHRoZSBub3RpZmljYXRpb25cclxuICAgIG5vdGlmaWNhdGlvbi5jbG9zZSgpO1xyXG5cclxuICAgIC8vIEhhbmRsZSBkaWZmZXJlbnQgYWN0aW9uc1xyXG4gICAgZXZlbnQud2FpdFVudGlsKGhhbmRsZU5vdGlmaWNhdGlvbkNsaWNrKGFjdGlvbiwgZGF0YSkpO1xyXG59KTtcclxuXHJcbi8qKlxyXG4gKiBOb3RpZmljYXRpb24gY2xvc2UgaGFuZGxlclxyXG4gKi9cclxuc2VsZi5hZGRFdmVudExpc3RlbmVyKFwibm90aWZpY2F0aW9uY2xvc2VcIiwgKGV2ZW50KSA9PiB7XHJcbiAgICBjb25zb2xlLmxvZyhcIk5vdGlmaWNhdGlvbiBjbG9zZWQ6XCIsIGV2ZW50KTtcclxuXHJcbiAgICBjb25zdCBkYXRhID0gZXZlbnQubm90aWZpY2F0aW9uLmRhdGEgfHwge307XHJcblxyXG4gICAgLy8gVHJhY2sgbm90aWZpY2F0aW9uIGRpc21pc3NhbFxyXG4gICAgZXZlbnQud2FpdFVudGlsKHRyYWNrTm90aWZpY2F0aW9uRXZlbnQoXCJkaXNtaXNzZWRcIiwgZGF0YSkpO1xyXG59KTtcclxuXHJcbi8qKlxyXG4gKiBTaG93IG5vdGlmaWNhdGlvbiB3aXRoIHByb3BlciBmb3JtYXR0aW5nXHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiBzaG93Tm90aWZpY2F0aW9uKHBheWxvYWQpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3Qge1xyXG4gICAgICAgICAgICB0aXRsZSxcclxuICAgICAgICAgICAgYm9keSxcclxuICAgICAgICAgICAgaWNvbiA9IEZBTExCQUNLX0lDT04sXHJcbiAgICAgICAgICAgIGJhZGdlID0gRkFMTEJBQ0tfQkFER0UsXHJcbiAgICAgICAgICAgIGltYWdlLFxyXG4gICAgICAgICAgICB0YWcsXHJcbiAgICAgICAgICAgIGRhdGEgPSB7fSxcclxuICAgICAgICAgICAgYWN0aW9ucyA9IFtdLFxyXG4gICAgICAgICAgICByZXF1aXJlSW50ZXJhY3Rpb24gPSBmYWxzZSxcclxuICAgICAgICAgICAgc2lsZW50ID0gZmFsc2UsXHJcbiAgICAgICAgICAgIHZpYnJhdGUgPSBbMjAwLCAxMDAsIDIwMF0sXHJcbiAgICAgICAgfSA9IHBheWxvYWQ7XHJcblxyXG4gICAgICAgIC8vIENyZWF0ZSBub3RpZmljYXRpb24gb3B0aW9uc1xyXG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XHJcbiAgICAgICAgICAgIGJvZHksXHJcbiAgICAgICAgICAgIGljb24sXHJcbiAgICAgICAgICAgIGJhZGdlLFxyXG4gICAgICAgICAgICBpbWFnZSxcclxuICAgICAgICAgICAgdGFnOiB0YWcgfHwgYCR7Tk9USUZJQ0FUSU9OX1RBR19QUkVGSVh9JHtEYXRlLm5vdygpfWAsXHJcbiAgICAgICAgICAgIGRhdGE6IHtcclxuICAgICAgICAgICAgICAgIC4uLmRhdGEsXHJcbiAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IERhdGUubm93KCksXHJcbiAgICAgICAgICAgICAgICB1cmw6IGRhdGEudXJsID8/IGdldE5vdGlmaWNhdGlvblVybChkYXRhLm5vdGlmaWNhdGlvblR5cGUgfHwgcGF5bG9hZC50YWcsIGRhdGEpLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBhY3Rpb25zOiBhY3Rpb25zLm1hcCgoYWN0aW9uKSA9PiAoe1xyXG4gICAgICAgICAgICAgICAgYWN0aW9uOiBhY3Rpb24uYWN0aW9uLFxyXG4gICAgICAgICAgICAgICAgdGl0bGU6IGFjdGlvbi50aXRsZSxcclxuICAgICAgICAgICAgICAgIGljb246IGFjdGlvbi5pY29uLFxyXG4gICAgICAgICAgICB9KSksXHJcbiAgICAgICAgICAgIHJlcXVpcmVJbnRlcmFjdGlvbixcclxuICAgICAgICAgICAgc2lsZW50LFxyXG4gICAgICAgICAgICB2aWJyYXRlOiBzaWxlbnQgPyBbXSA6IHZpYnJhdGUsXHJcbiAgICAgICAgICAgIHJlbm90aWZ5OiB0cnVlLFxyXG4gICAgICAgICAgICBwZXJzaXN0ZW50OiB0cnVlLFxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGNvbnNvbGUubG9nKFwiU2hvd2luZyBub3RpZmljYXRpb24gd2l0aCBvcHRpb25zOlwiLCBvcHRpb25zKTtcclxuXHJcbiAgICAgICAgLy8gU2hvdyB0aGUgbm90aWZpY2F0aW9uXHJcbiAgICAgICAgYXdhaXQgc2VsZi5yZWdpc3RyYXRpb24uc2hvd05vdGlmaWNhdGlvbih0aXRsZSwgb3B0aW9ucyk7XHJcblxyXG4gICAgICAgIC8vIFRyYWNrIG5vdGlmaWNhdGlvbiBkZWxpdmVyeVxyXG4gICAgICAgIGF3YWl0IHRyYWNrTm90aWZpY2F0aW9uRXZlbnQoXCJkZWxpdmVyZWRcIiwgZGF0YSk7XHJcblxyXG4gICAgICAgIGNvbnNvbGUubG9nKFwiTm90aWZpY2F0aW9uIHNob3duIHN1Y2Nlc3NmdWxseVwiKTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIHNob3dpbmcgbm90aWZpY2F0aW9uOlwiLCBlcnJvcik7XHJcbiAgICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBTaG93IGZhbGxiYWNrIG5vdGlmaWNhdGlvbiB3aGVuIHBheWxvYWQgaXMgaW52YWxpZFxyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gc2hvd0ZhbGxiYWNrTm90aWZpY2F0aW9uKHRpdGxlLCBib2R5KSB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XHJcbiAgICAgICAgICAgIGJvZHksXHJcbiAgICAgICAgICAgIGljb246IEZBTExCQUNLX0lDT04sXHJcbiAgICAgICAgICAgIGJhZGdlOiBGQUxMQkFDS19CQURHRSxcclxuICAgICAgICAgICAgdGFnOiBgJHtOT1RJRklDQVRJT05fVEFHX1BSRUZJWH1mYWxsYmFja2AsXHJcbiAgICAgICAgICAgIGRhdGE6IHtcclxuICAgICAgICAgICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcclxuICAgICAgICAgICAgICAgIHR5cGU6IFwiZmFsbGJhY2tcIixcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgcmVxdWlyZUludGVyYWN0aW9uOiBmYWxzZSxcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBhd2FpdCBzZWxmLnJlZ2lzdHJhdGlvbi5zaG93Tm90aWZpY2F0aW9uKHRpdGxlLCBvcHRpb25zKTtcclxuICAgICAgICBjb25zb2xlLmxvZyhcIkZhbGxiYWNrIG5vdGlmaWNhdGlvbiBzaG93blwiKTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIHNob3dpbmcgZmFsbGJhY2sgbm90aWZpY2F0aW9uOlwiLCBlcnJvcik7XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBIYW5kbGUgbm90aWZpY2F0aW9uIGNsaWNrIGV2ZW50c1xyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gaGFuZGxlTm90aWZpY2F0aW9uQ2xpY2soYWN0aW9uLCBkYXRhKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFwiSGFuZGxpbmcgbm90aWZpY2F0aW9uIGNsaWNrOlwiLCB7IGFjdGlvbiwgZGF0YSB9KTtcclxuXHJcbiAgICAgICAgLy8gVHJhY2sgY2xpY2sgZXZlbnRcclxuICAgICAgICBhd2FpdCB0cmFja05vdGlmaWNhdGlvbkV2ZW50KFwiY2xpY2tlZFwiLCB7IC4uLmRhdGEsIGFjdGlvbiB9KTtcclxuXHJcbiAgICAgICAgLy8gSGFuZGxlIHNwZWNpZmljIGFjdGlvbnNcclxuICAgICAgICBhd2FpdCBvcGVuTm90aWZpY2F0aW9uVXJsKGRhdGEpO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgaGFuZGxpbmcgbm90aWZpY2F0aW9uIGNsaWNrOlwiLCBlcnJvcik7XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBPcGVuIG5vdGlmaWNhdGlvbiBVUkwgaW4gY2xpZW50XHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiBvcGVuTm90aWZpY2F0aW9uVXJsKGRhdGEpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgdXJsID0gZGF0YS51cmwgfHwgZ2V0Tm90aWZpY2F0aW9uVXJsKGRhdGEubm90aWZpY2F0aW9uVHlwZSwgZGF0YSk7XHJcbiAgICAgICAgY29uc29sZS5sb2coXCJPcGVuaW5nIG5vdGlmaWNhdGlvbiBVUkw6XCIsIHVybCk7XHJcblxyXG4gICAgICAgIC8vIEZvY3VzIGV4aXN0aW5nIHdpbmRvdyBvciBvcGVuIG5ldyBvbmVcclxuICAgICAgICBjb25zdCBjbGllbnRzID0gYXdhaXQgc2VsZi5jbGllbnRzLm1hdGNoQWxsKHsgdHlwZTogXCJ3aW5kb3dcIiB9KTtcclxuXHJcbiAgICAgICAgZm9yIChjb25zdCBjbGllbnQgb2YgY2xpZW50cykge1xyXG4gICAgICAgICAgICBpZiAoY2xpZW50LnVybC5pbmNsdWRlcyh1cmwpICYmIFwiZm9jdXNcIiBpbiBjbGllbnQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjbGllbnQuZm9jdXMoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gT3BlbiBuZXcgd2luZG93XHJcbiAgICAgICAgaWYgKHNlbGYuY2xpZW50cy5vcGVuV2luZG93KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzZWxmLmNsaWVudHMub3BlbldpbmRvdyh1cmwpO1xyXG4gICAgICAgIH1cclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIG9wZW5pbmcgbm90aWZpY2F0aW9uIFVSTDpcIiwgZXJyb3IpO1xyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICogR2V0IG5vdGlmaWNhdGlvbiBVUkwgYmFzZWQgb24gdHlwZSBhbmQgZGF0YVxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0Tm90aWZpY2F0aW9uVXJsKG5vdGlmaWNhdGlvblR5cGUsIGRhdGEgPSB7fSkge1xyXG4gICAgY29uc29sZS5sb2coXCJHZXR0aW5nIG5vdGlmaWNhdGlvbiBVUkwgZm9yOlwiLCB7IG5vdGlmaWNhdGlvblR5cGUsIGRhdGEgfSk7XHJcblxyXG4gICAgaWYgKGRhdGEudXJsKSB7XHJcbiAgICAgICAgcmV0dXJuIGRhdGEudXJsO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGJhc2VVcmwgPSBOT1RJRklDQVRJT05fVVJMU1tub3RpZmljYXRpb25UeXBlXSB8fCBcIi9cIjtcclxuXHJcbiAgICAvLyBBZGQgc3BlY2lmaWMgSURzIGlmIGF2YWlsYWJsZVxyXG4gICAgaWYgKGRhdGEuYXBwb2ludG1lbnRJZCAmJiBiYXNlVXJsLmluY2x1ZGVzKFwiYXBwb2ludG1lbnRzXCIpKSB7XHJcbiAgICAgICAgcmV0dXJuIGAke2Jhc2VVcmx9LyR7ZGF0YS5hcHBvaW50bWVudElkfWA7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGRhdGEucHJlc2NyaXB0aW9uSWQgJiYgYmFzZVVybC5pbmNsdWRlcyhcInByZXNjcmlwdGlvbnNcIikpIHtcclxuICAgICAgICByZXR1cm4gYCR7YmFzZVVybH0vJHtkYXRhLnByZXNjcmlwdGlvbklkfWA7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGJhc2VVcmw7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUcmFjayBub3RpZmljYXRpb24gZXZlbnRzIGZvciBhbmFseXRpY3NcclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIHRyYWNrTm90aWZpY2F0aW9uRXZlbnQoZXZlbnQsIGRhdGEpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coXCJUcmFja2luZyBub3RpZmljYXRpb24gZXZlbnQ6XCIsIHsgZXZlbnQsIGRhdGEgfSk7XHJcblxyXG4gICAgICAgIC8vIFN0b3JlIGV2ZW50IGxvY2FsbHlcclxuICAgICAgICBjb25zdCBldmVudERhdGEgPSB7XHJcbiAgICAgICAgICAgIGV2ZW50LFxyXG4gICAgICAgICAgICBub3RpZmljYXRpb25UeXBlOiBkYXRhLm5vdGlmaWNhdGlvblR5cGUsXHJcbiAgICAgICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcclxuICAgICAgICAgICAgdXNlcklkOiBkYXRhLnVzZXJJZCxcclxuICAgICAgICAgICAgYXBwb2ludG1lbnRJZDogZGF0YS5hcHBvaW50bWVudElkLFxyXG4gICAgICAgICAgICBwcmVzY3JpcHRpb25JZDogZGF0YS5wcmVzY3JpcHRpb25JZCxcclxuICAgICAgICAgICAgYWN0aW9uOiBkYXRhLmFjdGlvbixcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvLyBTdG9yZSBpbiBJbmRleGVkREIgb3IgbG9jYWxTdG9yYWdlXHJcbiAgICAgICAgYXdhaXQgc3RvcmVOb3RpZmljYXRpb25FdmVudChldmVudERhdGEpO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgdHJhY2tpbmcgbm90aWZpY2F0aW9uIGV2ZW50OlwiLCBlcnJvcik7XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBTdG9yZSBub3RpZmljYXRpb24gZXZlbnQgbG9jYWxseVxyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gc3RvcmVOb3RpZmljYXRpb25FdmVudChldmVudERhdGEpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgLy8gRm9yIHNpbXBsaWNpdHksIHVzaW5nIGNhY2hlIEFQSSB0byBzdG9yZSBldmVudHNcclxuICAgICAgICAvLyBJbiBwcm9kdWN0aW9uLCB5b3UgbWlnaHQgd2FudCB0byB1c2UgSW5kZXhlZERCXHJcbiAgICAgICAgY29uc3QgY2FjaGUgPSBhd2FpdCBjYWNoZXMub3BlbihDQUNIRV9OQU1FKTtcclxuICAgICAgICBjb25zdCBldmVudEtleSA9IGBldmVudC0ke2V2ZW50RGF0YS50aW1lc3RhbXB9YDtcclxuXHJcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBuZXcgUmVzcG9uc2UoSlNPTi5zdHJpbmdpZnkoZXZlbnREYXRhKSwge1xyXG4gICAgICAgICAgICBoZWFkZXJzOiB7IFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH0sXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGF3YWl0IGNhY2hlLnB1dChldmVudEtleSwgcmVzcG9uc2UpO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFwiTm90aWZpY2F0aW9uIGV2ZW50IHN0b3JlZCBsb2NhbGx5XCIpO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3Igc3RvcmluZyBub3RpZmljYXRpb24gZXZlbnQ6XCIsIGVycm9yKTtcclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEJhY2tncm91bmQgc3luYyBmb3Igb2ZmbGluZSBldmVudHMgKG9wdGlvbmFsKVxyXG4gKi9cclxuc2VsZi5hZGRFdmVudExpc3RlbmVyKFwic3luY1wiLCAoZXZlbnQpID0+IHtcclxuICAgIGlmIChldmVudC50YWcgPT09IFwibm90aWZpY2F0aW9uLWV2ZW50cy1zeW5jXCIpIHtcclxuICAgICAgICBjb25zb2xlLmxvZyhcIkJhY2tncm91bmQgc3luYyB0cmlnZ2VyZWQgZm9yIG5vdGlmaWNhdGlvbiBldmVudHNcIik7XHJcbiAgICAgICAgZXZlbnQud2FpdFVudGlsKHN5bmNOb3RpZmljYXRpb25FdmVudHMoKSk7XHJcbiAgICB9XHJcbn0pO1xyXG5cclxuLyoqXHJcbiAqIFN5bmMgc3RvcmVkIG5vdGlmaWNhdGlvbiBldmVudHMgd2hlbiBvbmxpbmVcclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIHN5bmNOb3RpZmljYXRpb25FdmVudHMoKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IGNhY2hlID0gYXdhaXQgY2FjaGVzLm9wZW4oQ0FDSEVfTkFNRSk7XHJcbiAgICAgICAgY29uc3Qga2V5cyA9IGF3YWl0IGNhY2hlLmtleXMoKTtcclxuXHJcbiAgICAgICAgZm9yIChjb25zdCByZXF1ZXN0IG9mIGtleXMpIHtcclxuICAgICAgICAgICAgaWYgKHJlcXVlc3QudXJsLmluY2x1ZGVzKFwiZXZlbnQtXCIpKSB7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY2FjaGUubWF0Y2gocmVxdWVzdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXZlbnREYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xyXG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IGNhY2hlLmRlbGV0ZShyZXF1ZXN0KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJTeW5jZWQgbm90aWZpY2F0aW9uIGV2ZW50OlwiLCBldmVudERhdGEuZXZlbnQpO1xyXG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3Igc3luY2luZyBldmVudDpcIiwgZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgZHVyaW5nIG5vdGlmaWNhdGlvbiBldmVudHMgc3luYzpcIiwgZXJyb3IpO1xyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICogQ2xlYW4gdXAgb2xkIG5vdGlmaWNhdGlvbiBldmVudHNcclxuICovXHJcbnNlbGYuYWRkRXZlbnRMaXN0ZW5lcihcImFjdGl2YXRlXCIsIChldmVudCkgPT4ge1xyXG4gICAgZXZlbnQud2FpdFVudGlsKGNsZWFudXBPbGRFdmVudHMoKSk7XHJcbn0pO1xyXG5cclxuYXN5bmMgZnVuY3Rpb24gY2xlYW51cE9sZEV2ZW50cygpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgY2FjaGUgPSBhd2FpdCBjYWNoZXMub3BlbihDQUNIRV9OQU1FKTtcclxuICAgICAgICBjb25zdCBrZXlzID0gYXdhaXQgY2FjaGUua2V5cygpO1xyXG4gICAgICAgIGNvbnN0IG9uZVdlZWtBZ28gPSBEYXRlLm5vdygpIC0gNyAqIDI0ICogNjAgKiA2MCAqIDEwMDA7XHJcblxyXG4gICAgICAgIGZvciAoY29uc3QgcmVxdWVzdCBvZiBrZXlzKSB7XHJcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0LnVybC5pbmNsdWRlcyhcImV2ZW50LVwiKSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdGltZXN0YW1wID0gcGFyc2VJbnQocmVxdWVzdC51cmwuc3BsaXQoXCJldmVudC1cIilbMV0pO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRpbWVzdGFtcCA8IG9uZVdlZWtBZ28pIHtcclxuICAgICAgICAgICAgICAgICAgICBhd2FpdCBjYWNoZS5kZWxldGUocmVxdWVzdCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnNvbGUubG9nKFwiQ2xlYW5lZCB1cCBvbGQgbm90aWZpY2F0aW9uIGV2ZW50c1wiKTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGNsZWFuaW5nIHVwIG9sZCBldmVudHM6XCIsIGVycm9yKTtcclxuICAgIH1cclxufVxyXG5cclxuY29uc29sZS5sb2coXCJNeVRlbG1lZCBQdXNoIE5vdGlmaWNhdGlvbiBTZXJ2aWNlIFdvcmtlciBsb2FkZWRcIik7XHJcblxyXG4vLyBFeHBvcnQgZnVuY3Rpb25zIGZvciB0ZXN0aW5nXHJcbmlmICh0eXBlb2YgbW9kdWxlICE9PSBcInVuZGVmaW5lZFwiICYmIG1vZHVsZS5leHBvcnRzKSB7XHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcclxuICAgICAgICBzaG93Tm90aWZpY2F0aW9uLFxyXG4gICAgICAgIGhhbmRsZU5vdGlmaWNhdGlvbkNsaWNrLFxyXG4gICAgICAgIGdldE5vdGlmaWNhdGlvblVybCxcclxuICAgICAgICB0cmFja05vdGlmaWNhdGlvbkV2ZW50LFxyXG4gICAgfTtcclxufVxyXG4iXSwibmFtZXMiOlsiaW1wb3J0U2NyaXB0cyIsInNlbGYiLCJfX1dCX01BTklGRVNUIiwiY29uc29sZSIsImxvZyIsIk5PVElGSUNBVElPTl9UQUdfUFJFRklYIiwiQ0FDSEVfTkFNRSIsIkZBTExCQUNLX0lDT04iLCJGQUxMQkFDS19CQURHRSIsIk5PVElGSUNBVElPTl9VUkxTIiwiQVBQT0lOVE1FTlRfUkVNSU5ERVJfUEFUSUVOVCIsIkFQUE9JTlRNRU5UX0NPTkZJUk1BVElPTl9QQVRJRU5UIiwiQVBQT0lOVE1FTlRfQ0FOQ0VMX1BBVElFTlQiLCJBUFBPSU5UTUVOVF9CT09LRURfUEFUSUVOVCIsIlBSRVNDUklQVElPTl9DUkVBVEVEIiwiUFJFU0NSSVBUSU9OX0VYUElSSU5HIiwiYWRkRXZlbnRMaXN0ZW5lciIsImV2ZW50IiwiZGF0YSIsInBheWxvYWQiLCJqc29uIiwidGl0bGUiLCJib2R5IiwiZXJyb3IiLCJ3YWl0VW50aWwiLCJzaG93Tm90aWZpY2F0aW9uIiwic2hvd0ZhbGxiYWNrTm90aWZpY2F0aW9uIiwibm90aWZpY2F0aW9uIiwiYWN0aW9uIiwiY2xvc2UiLCJoYW5kbGVOb3RpZmljYXRpb25DbGljayIsInRyYWNrTm90aWZpY2F0aW9uRXZlbnQiLCJpY29uIiwiYmFkZ2UiLCJpbWFnZSIsInRhZyIsImFjdGlvbnMiLCJyZXF1aXJlSW50ZXJhY3Rpb24iLCJzaWxlbnQiLCJ2aWJyYXRlIiwib3B0aW9ucyIsIkRhdGUiLCJub3ciLCJ0aW1lc3RhbXAiLCJ1cmwiLCJnZXROb3RpZmljYXRpb25VcmwiLCJub3RpZmljYXRpb25UeXBlIiwibWFwIiwicmVub3RpZnkiLCJwZXJzaXN0ZW50IiwicmVnaXN0cmF0aW9uIiwidHlwZSIsIm9wZW5Ob3RpZmljYXRpb25VcmwiLCJjbGllbnRzIiwibWF0Y2hBbGwiLCJjbGllbnQiLCJpbmNsdWRlcyIsImZvY3VzIiwib3BlbldpbmRvdyIsImJhc2VVcmwiLCJhcHBvaW50bWVudElkIiwicHJlc2NyaXB0aW9uSWQiLCJldmVudERhdGEiLCJ1c2VySWQiLCJzdG9yZU5vdGlmaWNhdGlvbkV2ZW50IiwiY2FjaGUiLCJjYWNoZXMiLCJvcGVuIiwiZXZlbnRLZXkiLCJyZXNwb25zZSIsIlJlc3BvbnNlIiwiSlNPTiIsInN0cmluZ2lmeSIsImhlYWRlcnMiLCJwdXQiLCJzeW5jTm90aWZpY2F0aW9uRXZlbnRzIiwia2V5cyIsInJlcXVlc3QiLCJtYXRjaCIsImRlbGV0ZSIsImNsZWFudXBPbGRFdmVudHMiLCJvbmVXZWVrQWdvIiwicGFyc2VJbnQiLCJzcGxpdCIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./public/sw-push.js\n"));

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			if (cachedModule.error !== undefined) throw cachedModule.error;
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		var threw = true;
/******/ 		try {
/******/ 			__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 			threw = false;
/******/ 		} finally {
/******/ 			if(threw) delete __webpack_module_cache__[moduleId];
/******/ 		}
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/trusted types policy */
/******/ 	!function() {
/******/ 		var policy;
/******/ 		__webpack_require__.tt = function() {
/******/ 			// Create Trusted Type policy if Trusted Types are available and the policy doesn't exist yet.
/******/ 			if (policy === undefined) {
/******/ 				policy = {
/******/ 					createScript: function(script) { return script; }
/******/ 				};
/******/ 				if (typeof trustedTypes !== "undefined" && trustedTypes.createPolicy) {
/******/ 					policy = trustedTypes.createPolicy("nextjs#bundler", policy);
/******/ 				}
/******/ 			}
/******/ 			return policy;
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/trusted types script */
/******/ 	!function() {
/******/ 		__webpack_require__.ts = function(script) { return __webpack_require__.tt().createScript(script); };
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/react refresh */
/******/ 	!function() {
/******/ 		if (__webpack_require__.i) {
/******/ 		__webpack_require__.i.push(function(options) {
/******/ 			var originalFactory = options.factory;
/******/ 			options.factory = function(moduleObject, moduleExports, webpackRequire) {
/******/ 				var hasRefresh = typeof self !== "undefined" && !!self.$RefreshInterceptModuleExecution$;
/******/ 				var cleanup = hasRefresh ? self.$RefreshInterceptModuleExecution$(moduleObject.id) : function() {};
/******/ 				try {
/******/ 					originalFactory.call(this, moduleObject, moduleExports, webpackRequire);
/******/ 				} finally {
/******/ 					cleanup();
/******/ 				}
/******/ 			}
/******/ 		})
/******/ 		}
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/compat */
/******/ 	
/******/ 	
/******/ 	// noop fns to prevent runtime errors during initialization
/******/ 	if (typeof self !== "undefined") {
/******/ 		self.$RefreshReg$ = function () {};
/******/ 		self.$RefreshSig$ = function () {
/******/ 			return function (type) {
/******/ 				return type;
/******/ 			};
/******/ 		};
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./public/sw-push.js");
/******/ 	
/******/ })()
;